{"pages":[{"text":"Hey there! My name is Achilleas Pipinellis and you reached the about me page :) Here you will find some info about the projects I contribute to, as well as some personal things, like what my hobbies are. You can contact me via email or reach to me through the social media. See at the bottom of this page for contact details. Open source matters GitLab GitLab is an open source git repository application, built on Ruby on Rails. I have been using it since version 2.0 and started contributing in version 4.0. As of April 2014 I am a member of the community core-team as GitLab recipes lead. I also help at the bug tracker, so if you want to ping me, use @axil . Fedora In early 2013 I started getting involved with Fedora , mainly because of the GSoC 2013 program. It has a vast community with many developers, sysadmins and users and a lot of areas you can contribute to. I currently maintain some packages , mostly rubygems. I had the pleasure to participate in the Google Summer of Code program in 2013 and 2014 with the Fedora project. See more info in my Fedora wiki page . Foss Ntua We have a local free and open source community in my university where I am a sysadmin. We host several services, among others: a wiki based on MediaWiki a forum based on Discourse a git server based on GitLab a public server hosting our members' personal sites a dns server a mail server an xmpp server based on prosody Apart from the forum we also have a mailing list . Some overview of the uptime status of the services can be found here . Archlinux I've been using Archlinux as my main distribution since 2007. I maintain several packages at the AUR and I try to contribute to the Archwiki whenever I can. I am also a member of an unofficial package team in Greece, where we serve a repository with popular packages that aren't in the official repos. I have also contributed to the localization of pacman and the AUR interface. Check my transifex profile at Contact Details. Recently I helped to package the snf-image-creator tool of the synnefo IaaS. Workstation I am a proud owner of a Thinkpad x220 running Archlinux. ## OS: Arch Linux x86_64 #### Hostname: thedude ###### Uptime: 5 days, 8:57 ######## Kernel: 3.17.2-1-ARCH ########## Shell: /bin/zsh ############ Packages: 1702 ############## DE: KDE ################ GTK2 theme: QtCurve ################## GTK2 icon theme: Numix #################### GTK2 font name: Sans Serif 9 ###################### RAM: 4394M / 7871M (55%) ######### ######### CPU: Intel(R) i7-2640M CPU @ 2.80GHz ########## ########## Boot: 80M / 1022M (8%) (vfat) ########### ########### Root: 192G / 234G (87%) (ext4) ########## ########## SSD : 256GB Samsung Pro ####### ####### #### #### ### ### Hobbies/Interests Aikido My greatest love is Aikido , a japanese martial art. I first started in January 2010 and have attended a bunch of seminars since. There is a site of our dojo and some social pages ( facebook , twitter , youtube ). You can check some photos in the facebook page. My limited skills on graphical design led me to do the artwork of our dojo as well. Source files can be found on github . Photography I have an old Olympus DSLR and whenever I have the chance I get pictures. My main interest is my pets, but I also take landscapes as well. Some day I hope to buy a more advanced camera which supports custom firmware in order to hack it :p I'll post a link with my photos once I get them sorted Online Courses Probably not much of a hobby but I do these on my free time, so: Codeschool report card Coursera profile Favorites Movies I like watching movies and TV series. I always enjoy the Asian cinema and the Japanese Anime movies and series. Did I mention that I also like manga? With no particular order (well, except from the first one), some of my favorite movies are: The Big Lebowski Sin City 12 Angry Men Drive Nine Queens Paprika Weekend at Bernie's Black Dynamite 13 Assassins Hot Fuzz Spirited Away Music I used to play keyboard 1 in a band, but unfortunately I haven't practised for a looong time. I also own an electric guitar. Other than playing, I like listening to music. When working or studying, most of the times I listen to jazz because I find it non distracting. Other music genres that I like are funk, blues, and progressive rock/metal. Often you'll also find me listening to 8bit, dubstep, and electronic :) If I had to pick one band that I miss not seeing live, that would be Rush. Contact details Email : axilleas [ at ] axilleas [ dot ] me IRC : axil42 ( freenode , mozilla ) PGP key : 0x3 A7DDABC985EDC6E Github : axilleas Twitter : _axil Google + : https :// plus . google . com /u/0/ 108076288136257590130 Transifex : https :// transifex . com /accounts/profile/kissmyarch/ FAS &#94;[ fas ] : axilleas Proud owner of a Roland Juno-D. ↩ Fedora Account System ↩","tags":"pages","loc":"http://axilleas.me/about","title":"whoami"},{"text":"All fedora gitlab gsoc ruby rails","tags":"pages","loc":"http://axilleas.me/rss","title":"Rss Feed"},{"text":"It's been a long time since last I showed some love for the UI of this blog, and after a day of modifications I'm pretty excited about the outcome :w00t: So, what has changed? UI redesign New plugins used search neighboring articles post statistics Source code UI redesign I like simple things and I always wanted the same thing for my blog. Few years ago, I had come across a static site built with jekyll and loved its simplicity. My new theme is heavilly inspired by http://uberspot.github.io , hence the name I decided to give it. This nice feature of rotating pictures with every new visit isn't implemented yet for pelican, but it's in my plans. Vincent Bernat's blog has also been an inspiration and you'll see many css styles taken from there, for example the table of contents. Apart from design patterns, he is writing some very cool stuff so I urge you to follow him. I prefer the light themes over the darks ones, but not too bright. The background is taken from subtle patterns , an awesome site that has many patterns to choose from. I went with paper fibers and I like the outcome so far. The main font used is Merriweather from Google's webfonts and was inspired to use by Vincent's blog. Code blocks are styled after Mozilla's Developer Network, here is a sample taken form here : var foo = 42 ; // foo is a Number now var foo = \"bar\" ; // foo is a String now var foo = true ; // foo is a Boolean now pygments is used underneath and I picked the friendly style. Blockquotes are restyled to use sharp edges and a light orange color: Look, let me explain something. I'm not Mr. Lebowski. You're Mr. Lebowski. I'm the Dude. So that's what you call me. That, or Duder, or His Dudeness, or El Duderino, if you're not into the whole brevity thing. New plugins used Pelican has a very active community and its powerful structure make it dead easy to add a plugin or even write your own. Head over the pelican-plugins repo and see your options. For the time being I chose to use three plugins that add some pretty nice functionality to the UI and UX. search Being a static site, the only way to add some search functionality is by using javascript. Thankfully, there is a jquery plugin that does exactly that and is named tipue search . Some nice guy provided a pelican plugin so I took a shot and used it. There isn't much information in the docs how to set it up, but after a little search, I found some articles that explained it in depth. http://moparx.com/2014/04/adding-search-capabilities-within-your-pelican-powered-site-using-tipue-search/ http://www.futurile.net/2014/04/19/sitesearch-for-pelican-blog-with-tipue/ neighboring articles The neighbors plugin adds next_article (newer) and prev_article (older) variables to the article's context. As you'll see I added some nice bowling pins icons to show you the way :) post statistics A really nice plugin is the post_stats which calculates various statistics about a post and stores them in an article.stats dictionary. Now you get the average time to read a post, and if you hover over it, you also see the total words written. Source code As always, the source code is available to take a look and hack on. I haven't yet submitted it to the pelican-themes repo as I need to sort some things and clean it up a bit.","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/pelican-new-theme-redesign","title":"Redesigning the looks of this blog"},{"text":"The past week I tried to do something about the looks of isitfedoraruby. It was fun using bootstrap (my first time) and I think the outcome is cool. I tried to use Fedora like colors and the font is Liberation Sans , same as Fedora pkgdb . You can check the overall changes: Before: http://www.isitfedoraruby.com/ After: http://fedoraruby.axilleas.me/ Tables fedorarpms index page show page rubygems show page owner page Navigation bar Active links Navbar header Dropdown menu Search field Responsive design Tables They are now borderless, with highlighted headings. They are also responsive which means if the table is bigger than the page it gets its own sidebar without breaking the rest of the site. fedorarpms index page The index page show all packaged rubygems along with some interesting info. You can see if a package is out of date if is highlighted with a red color. On the other hand green means is up to date with latest upstream. The code that does that is pretty simple. Bootstrap provides some css classes for coloring. So I wanted to use warning for outdated and success for up to date packages. I highlighted the whole table row so I used: %tr { class: rpm.up_to_date? ? 'success' : 'danger' } In particular check line 19 . show page Previously there was a ton of information all in one page. Now, the info is still there but I have devided it into tab sections. Currently there are 5 tabs. The main tab has a gem's basic info: Up to date badge (green yes or red no) Gitweb repository url SPEC file url Upstream url Maintainer FAS name Number of git commits Last packager (in case a package is co-maintained) Last commit message Last commit date Description Then there is a tab about version information: Table with gem versions across supported Fedora versions (rawhide, 21, 20) Another important tab is a list with a packages's dependencies: One table with dependencies with column whether they are runtime/development deps One table with dependents packages The bugs tab depicts all of package's open bugs for Fedora in a table. And lastly koji builds for only the supported Fedora versions. rubygems show page The description is now on top of the page. Instead of one column, the new look has two columns, one for basic info and one for the depdendencies table. Compare rake: Before : http://www.isitfedoraruby.com/rubygems/rake After : http://fedoraruby.axilleas.me/rubygems/rake owner page I added some info on top of the page about the number of the packages a user owns: Total Up to date Outdated The table that has an owner's packages is also highlighted to depict outdated and up to date packages. Here's an embarassing screenshot which reminds me I have to update my packages... Navigation bar The navigation bar was a PITA to configure and make as responsive as possible. There were a lot of bits and pieces needed to fit together, here are some of them. Active links I used a helper method which I found in this so answer . Helper method View implementation Navbar header I used the same colors of Fedora pkgdb . With the help of a firefox extension named colorpicker and http://twbscolor.smarchal.com/ I gave the navbar the color it has now. twbscolor is a cool site that extracts your chosen color even in scss, which I used along with some minor tweaks. Dropdown menu In responsive mode there is a dropdown menu. That requires some javascript and the steps are: 1.Add *= require bootstrap in app/assets/stylesheets/application.css 2.Add //= require bootstrap in app/assets/javascripts/application.js 3.Add in app/assets/javascripts/application.js : $( '#header-collapse' ) .collapse ({ toggle: false }) 4.Add bootstrap classes to header view: %header . navbar . navbar - default . navbar - fixed - top . container . navbar - header %button . navbar - toggle { type : ' button ' , data : { toggle : ' collapse ' , target : ' #header - collapse ' }} %span . sr - only ' Toggle navigation ' %span . icon - bar %span . icon - bar %span . icon - bar %span . icon - bar = link_to ' FedoraRuby ' , root_path , class : ' navbar - brand ' %nav . collapse . navbar - collapse #header - collapse { role : ' navigation ' } %ul . nav . navbar - nav %li { class : is_active ? ( root_path )} = link_to _ ( ' Home ' ), root_path %li { class : is_active ? ( rubygems_path )} = link_to _ ( ' Ruby Gems ' ), rubygems_path %li { class : is_active ? ( fedorarpms_path )} = link_to _ ( ' Fedora Rpms ' ), fedorarpms_path %li { class : is_active ? ( about_path )} = link_to _ ( ' About ' ), about_path Search field I wanted the search field to be together with the search button. In bootstrap this is accomplished with input-group-buttons . The final code was: %ul.nav.navbar-nav.navbar-right %li = form_tag ( { :controller = > 'searches' , :action = > 'redirect' } , :class = > 'navbar-form' , :method = > 'post' ) do .input-group = text_field_tag :search, params [ :search ] ||= '' , class: 'search-query form-control' , placeholder: 'Search' %span.input-group-btn = button_tag raw ( '<span class=\"glyphicon glyphicon-search\"></span>' ) , name: nil, class: 'btn btn-default' Instead for a search button with text, I used an icon. There was also another problem regarding responsiveness. In different page sizes the header looked ugly and the search bar was getting under the menu. I fixed it by adding a media query in custom.css.scss that disappears the logo in certain widths. @media (min-width: 768px) and (max-width: 993px) { .navbar-brand { display: none } } Here are before/after screenshots to better understand it. Responsive design Bootstrap comes with responsiveness by default. In order to activate it you have to add a viewport meta tag in the head of your html, so in app/views/layouts/application.html.haml add: %meta { :content = > \"width=device-width, initial-scale=1, maximum-scale=1\" , :name = > \"viewport\" } See full application.html.haml It sure was fun and I learned a lot during the process of searching and fixing stuff :)","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/isitfedoraruby-new-design","title":"IsItFedoraRuby new design"},{"text":"With the release of GitLab 7.1 , the login page now looks like the default Enterprise Edition. Although in EE customizing the page should be easier to configure, we can do the same with Community Edition following some simple steps. If you are familiar with haml and bootstrap this should be fairly easy for you. Again, prerequisite is to have at least GitLab 7.1. You can see the final changes in this commit . Here is a before/after screenshot that we will gradually change. Introductory steps haml identation git branch Change brand logo Change text Brand title Body description Change footer links Change font Commit changes Updating GitLab Reverting changes What about omnibus? Introductory steps haml identation It is important to use an editor that has set a tab to two spaces. Haml depends on indentation so any mistake will yield errors. If you see any 500 errors, it means something went wrong. Either check the unicorn logs or better, run git diff to see if there are any indentation errors. If you are using vim, create/open /home/git/.vimrc and place the following lines: set tabstop=2 set shiftwidth=2 set expandtab That will ensure proper indentation handling. git branch In order to have more seamless future updates, let's create a separate git branch: su - git cd /home/git/gitlab/ git checkout -b custom_login_page All changes we make from now on, will be on that branch without creating any mess in future updates. Read below on how to update. The main file we need to change is app/views/layouts/devise.html.haml , relative to where GitLab is installed. Change brand logo Choose the image you want to appear in the login page and place it in /home/git/gitlab/app/assets/images/ . Next, open app/views/layouts/devise.html.haml with an editor and change line 22 replacing brand_logo.png with your image name including its extension. Since we alter the production server, remember to recompile the assets so that the Rails asset pipeline picks the new image (do that every time you put a new file or change something in app/assets/ ): cd /home/git/gitlab/ sudo -u git RAILS_ENV = production bundle exec rake assets:precompile Finally, restart the GitLab service to see the changes. Change text Apart from the logo, there is a lot more we can change. Let's try changing the text. Brand title In order to change the text reading GitLab Community Edition , open devise.html.haml and change %h1= brand_title in line 9 into %h1 My custom brand title . Here, we removed the equal sign because it is used by haml to evaluate and print ruby code ( brand_title is a helper method). If you want an image instead, you can replace %h1= brand_title with = image_tag 'my_banner.png' . Body description As you'd imagine, changing the body headline would require to replace %h2 Open source software to collaborate on code with our own text, or even remove it completely. The main body can be changed by altering the text that lies below %p.lead . Remember to indent correctly. The text can also contain links. Place each link in its own line. An example would be: Accounts are temporarily created manually, you can ask one in our = link_to \"forum discussion\", \"https://forum.example.com/gitlab-reg\" You can find more info in the = link_to \"Wiki.\", \"https://example.com/wiki/index.php/GitLab\" A link can also have a target = \"_blank\" to open in a new window. The format is: = link_to \"text\", \"http://example.com\", target: \"blank\" Change footer links Footer links are in line 35 . Just change their content or add new ones like we talked above. Change font The text I used was in Greek, so it looked aweful since the default font is Helvetica Neue . I decided to change it and use a webfont that supports my language. I went with Open Sans from https://www.google.com/fonts . Now, there are 3 changes we need to do: Create our custom css file which imports the font and sets the classes Change devise.html.haml and include the new css classes. Include our custom css in application.scss . For the first step I created app/assets/stylesheets/custom_login.scss with contents: @import url ( http : // fonts . googleapis . com / css ? family = Open + Sans & subset = latin , greek ); . custom - login { h1 , h2 , p { font - family : 'Open Sans' , sans - serif ; } } Here I used sass . These are nested values that will be picked by html. The second step is to change devise.html.haml and include the new custom-login css class. There were 2 places where I needed to do that: - .brand_text.hidden-xs + .brand_text.hidden-xs.custom-login - %p.lead + %p.lead.custom-login Third step is to include the custom css in application.scss . I opened app/assets/stylesheets/application.scss and appended at the very end of the file the following: /** * Styles for custom login page */ @import \"custom_login.scss\" ; Finally, in order for the new css to get included in the asset pipeline I precompiled the assets one more time: cd /home/git/gitlab/ sudo -u git RAILS_ENV = production bundle exec rake assets:precompile And while I was trying to precompile the assets after adding my custom css, it failed to do so because of a missing semicolon in application.scss . I immediately opened a Merge Request , so either wait for it to get merged or add it yourself for now. You got to love open source :) Screenshots of before/after font change. You can see that before the changes Greek and English words are using different fonts. Commit changes The login page should now work correctly providing all the needed info for our users. It's time to commit our changes. Check the diff with git diff one more time, and make sure you are on the right branch with git branch . It should show * custom_login_page . Add and commit the changed files: git add app/ git commit -m 'Custom login page.' Updating GitLab The trickiest part is to maintain the code through the updates and avoid as many confilcts as possible. Before each update, these are the basic steps: Stop gitlab service Run git fetch --all Run git branch 7-1-stable origin/7-1-stable (replace with appropriate version) Run git rebase 7-1-stable custom_login Follow the rest of instructions (db:migrate, assets:precompile, etc.) The trick here is rebase. This git command will replay our changes over the new branch we fetched from upstream. If there are no conflicts, the custom login changes will remain. Otherwise, git will inform you and then you'd have to first resolve any issues before rebasing. Reverting changes In order to revert to the original login page, it's as simple as changing branches and restarting the GitLab service. What about omnibus? If you have installed GitLab through the omnibus packages, the GitLab root path will be /opt/gitlab/embedded/service/gitlab-rails/ so make any changes relative to that path. I haven't tested it yet though, so I don't know whether any changes get rewritten with package updates (probably that is the case). On the other hand, if you work at a company that uses omnibus, consider going for the Enterprise Edition where this process would be more easier and at the same time you support the future development of GitLab :)","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/custom-gitlab-login-page","title":"Custom GitLab login page"},{"text":"This sums up my past month involvement with the project. A lot of reading in between... Changelog Rails/Ruby style guide Tests Bugs fixed wrong owners dependencies shown twice duplicate homepage and source uri Enhancements Show more info in fedorarpm show page Rake tasks Changelog I added a changelog so that the changes are easily seen, so here it is (this week is v 0.9.1): v 0.9 . 1 - Refactor rake tasks - Source Code uri in fedorarpms , points to pkgs . fp . o gitweb - Add first integration tests - Retrieve commit data via Pkgwat - Show name of last packager in fedorarpms #show - Show last commit message in fedorarpms #show - Show last commit date in fedorarpms #show - Use api to fetch rawhide version instead of scrapping page - Retrieve homepage via Pkgwat - Fix duplication of dependencies in fedorarpms #show - Do not show source url in rubygems #show if it is the same as the homepage - Do not show source url in fedorarpms #show if it is the same as the homepage - Split methods : versions , dependencies in fedorarpm model - New rake tasks to import versions , dependencies and commits - Show last packager in fedorarpms #show - Show last commit message in fedorarpms #show - Show last commit date in fedorarpms #show v 0.9 . 0 - Remove unused code - Remove HistoricalGems model - Remove Build controller / view - Remove methods related to local spec / gem downloading - Remove empty helpers - Cleaned routes , removed unused ones - Conform to ruby / rails style guide - Maintainer field for packages are now using the fas_name - Automatically fetch versions of Fedora by querying the pkgdb api - Addded rake task to fetch rawhide version and store it in a file locally - Show koji builds from supported Fedora versions only - Bugs - Query bugs via api using pkgwat - Drop is_open from bugs table - Show only open Fedora bugs , exclude EPEL - Hover over links to see full titles when truncated - Rename builds table to koji_builds - Added tests - Unit tests for models - Added Github services - travis - ci - hound - ci - coveralls - gemnasium - Development tools - shoulda - matchers - rspec - capybara - rack - mini - profiler - rubocop - factory_girl - annotate - railsroady You should notice some version numbers. That's also a new addition and every week I will deploy a new version, so eventually at some point in the end of the summer, version 1.0.0 will be released. Here are some nice stats from git log. Git stats : 91 commits / 4,662 ++ / 2,874 -- Rails/Ruby style guide Fixed arround 500 warnings that rubocop yielded. Tests Added: unit tests for models. Missing: A bunch of code still needs testing, rspec is not enough to properly test api calls. I will use vcr and webmock in the future to cover these tests. Integration tests are also not complete yet. Bugs fixed wrong owners Previously it parsed the spec file and checked the first email in the changelog. Co-maintainers have also the ability to build a package and in that case it shows wrong info. Another case is where a user changes their email they are taken into account twice, so when hitting /by_owner not all packages are shown. I was hit by this bug. It now fetches the owner's fas name using pkgwat which I use to sort by owner. dependencies shown twice The current implementation scraps the SPEC file of a rubygem via the gitweb and then stores the dependencies. The problem is that when one uses gem2rpm, ~> is expanded to >= and <= , which leads to list some dependencies twice. The fix was quite easy. Here is the controller that is in charge for the show action: def show @name = params [ :id ] @rpm = FedoraRpm . find_by_name! @name @page_title = @rpm . name @dependencies = @rpm . dependency_packages . uniq @dependents = @rpm . dependent_packages . uniq rescue ActiveRecord :: RecordNotFound redirect_to action : 'not_found' end All I did was to add uniq . duplicate homepage and source uri In a gem page you could see this: The information is taken from the https://rubygems.org api. Some have the same page for both gem's homepage and source uri. The secret was lying in the [view][]. % div . info % h3 Gem Information % p Homepage : = link_to @gem . homepage , @gem . homepage - unless @gem . source_uri . blank? % p Source Code : = link_to @gem . source_uri , @gem . source_uri All I did was to change this from this: - unless @gem . source_uri . blank? to this: - unless @gem . source_uri . blank? || @gem . source_uri == @gem . homepage So now it skips showing the homepage if it is the same as the source uri. Enhancements Show more info in fedorarpm show page I added some more information at the fedorarpm page. Now it shows, last packager, last commit message and last commit date. Useful if something is broken with the latest release and you want to blame someone :p And since many times a package has many co-maintainers you get to see the real last packager. Here's a shot of the page as it is now: Rake tasks As I have made some major refactoring in the fedorarpms model, I split many methods to their own namespace. For example, previously there was a single method for importing the versions and dependencies, now they are two separate. As a consequense, I added rake tasks that could be invoked for a single package. Also the namespace is now more descriptive. The tasks are for now the following: rake fedora:gem:import:all_names # FEDORA | Import a list of names of ALL gems from rubygems.org rake fedora:gem:import:metadata[number,delay] # FEDORA | Import gems metadata from rubygems.org rake fedora:gem:update:gems[age] # FEDORA | Update gems metadata from rubygems.org rake fedora:rawhide:create # FEDORA | Create file containing Fedora rawhide(development) version rake fedora:rawhide:version # FEDORA | Get Fedora rawhide(development) version rake fedora:rpm:import:all[number,delay] # FEDORA | Import ALL rpm metadata (time consuming) rake fedora:rpm:import:bugs[rpm_name] # FEDORA | Import bugs of a given rubygem package rake fedora:rpm:import:commits[rpm_name] # FEDORA | Import commits of a given rubygem package rake fedora:rpm:import:deps[rpm_name] # FEDORA | Import dependencies of a given rubygem package rake fedora:rpm:import:gem[rpm_name] # FEDORA | Import respective gem of a given rubygem package rake fedora:rpm:import:koji_builds[rpm_name] # FEDORA | Import koji builds of a given rubygem package rake fedora:rpm:import:names # FEDORA | Import a list of names of all rubygems from apps.fedoraproject.org rake fedora:rpm:import:versions[rpm_name] # FEDORA | Import versions of a given rubygem package rake fedora:rpm:update:oldest_rpms[number] # FEDORA | Update oldest <n> rpms rake fedora:rpm:update:rpms[age] # FEDORA | Update rpms metadata That was it for now. For any changes be sure to check out the changelog regularly!","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/isitfedoraruby-gsoc-midterm-sum-up","title":"isitfedoraruby gsoc midterm sum up"},{"text":"During the past two months I have been reading constantly about Rails and how I could get more productive when writing code and testing my apps. There is a ton of information about those matters on the web and I'll try to include as many articles as I could find useful to my knowledge building. Disclaimer: This article is heavily inspired by Thoughtbot's Vim for Rails Developers which I stumbled upon during browsing the screencasts of codeschool . Editor of choice (vim) vim plugins rails.vim vim-snipmate fugitive.vim Terminal multiplexer (tmux) Development stack jazz_hands rubocop railroady annotate Testing stack rspec capybara guard Other super useful tools ctags Installation Configuration Usage Secret power ack alternative (ag) Conclusion Editor of choice (vim) When you work from the command line and you use linux, your editor preference comes down to two choices: vim and emacs. I started with vim some time ago so I'll stick with it. If you are new to vim read this cheatsheet to learn the basical commands. vim plugins Start by installing pathogen.vim , a vim plugin manager: mkdir -p ~/.vim/autoload ~/.vim/bundle && \\ curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim Then add this to your vimrc: execute pathogen#infect() From now on, every plugin that is compatible with pathogen can be simply installed by cloning its repo at ~/.vim/bundle . An alternative for pathogen is vundle . Haven't used it but it behaves similarly. rails.vim Probably the one most useful plugin when dealing with Rails projects. Install it with: git clone git://github.com/tpope/vim-rails.git ~/.vim/bundle/vim-rails Browsing through the app You can use :RController foos and it will take you straight to the app/controllers/foos_controller.rb . As you might guess, same happens with :RModel foo , etc. There is also tab completion so that you can toggle between all models/controllers, etc. Another useful command is :find . Invoking it with a name foo, it first searches for a model named foo. Tab completion is also your friend. One other really cool feature is the go to file. Supposedly we have the following model: class Blog < ActiveRecord :: Base has_many :articles end Placing the cursor on the articles word and pressing gf vim opens the article model. After saving your changes you can go back to the blog model by pressing Ctrl-o . Run your tests through vim Running test is also a matter of a command. Say you are editing a specific spec/test file. All you have to do is run :Rake and the tests for that particular file will be ran, without leaving your favorite editor :) The supported commands are a lot and your best bet is to invoke :help rails in vim and learn about them. Be sure to also check vim-rails on github. vim-snipmate SnipMate implements snippet features in Vim. A snippet is like a template, reducing repetitive insertion of pieces of text. Snippets can contain placeholders for modifying the text if necessary or interpolated code for evaluation. Install it: cd ~/.vim/bundle git clone https://github.com/tomtom/tlib_vim.git git clone https://github.com/MarcWeber/vim-addon-mw-utils.git git clone https://github.com/garbas/vim-snipmate.git git clone https://github.com/honza/vim-snippets.git List of supported Ruby snippets List of supported Rails snippets Writing a method Reading the source code of snippets above let's see how we can create a method. The snippet reads: snippet def def ${ 1 : method_name } ${ 0 } end So, the snippet is named def and in order to invoke it we must write def and hit Tab. It then expands, placing the cursor in the highlited method_name . This is what it looks like: def method_name end Once you start typing, method_name gets replaced with what you type. When you finish, hit Tab again to go to the method body. Now all you have to do is read the ruby.snippet and find out what snippets are supported. fugitive.vim vim-fugitive brings the power of git commands inside vim. Install it with: git clone git://github.com/tpope/vim-fugitive.git ~/.vim/bundle/vim-fugitive Check out the github page for a list of commands and some interesting screencasts. Terminal multiplexer (tmux) Again, here you have two options. screen or tmux . My first contact was with screen but recently I decided to try tmux. I won't go into any details but I highly reccomend watching Chris Hunt's presentation Impressive Ruby Productivity with Vim and Tmux . It's an awesome talk. Development stack There is a great article I stumbled upon yesterday about some must have gems for development, some of which I haven't tested. Here is what I got so far. jazz_hands jazz_hands is basically a collection of gems that you get for free with just one gem. It focuses on enhancing the rails console. It provides: - Pry for a powerful shell alternative to IRB. - Awesome Print for stylish pretty print. - Hirb for tabular collection output. - Pry Rails for additional commands (show-routes, show-models, show-middleware) in the Rails console. - Pry Doc to browse Ruby source, including C, directly from the console. - Pry Git to teach the console about git. Diffs, blames, and commits on methods and classes, not just files. - Pry Remote to connect remotely to a Pry console. - Pry Debugger to turn the console into a simple debugger. - Pry Stack Explorer to navigate the call stack and frames. - Coolline and Coderay for syntax highlighting as you type. Optional. MRI 1.9.3/2.0.0 only Again, visiting the github page, you will get all the info you want. There is an open issue and installation on ruby 2.1.2 is failing for now. For the time being you can put the following in your Gemfile: gem 'jazz_hands', github: 'nixme/jazz_hands', branch: 'bring-your-own-debugger' gem 'pry-byebug' rubocop rubocop is a tool which checks if your code conforms to the ruby / rails community guidelines. You can check the article I wrote where I explain how to set it up and running. railroady railroady is a tool that lets you visualize how the models and the controllers of your app are structured. Instructions on how to install it are on the github page. You can check how it looks like on the fedoraruby project I'm currently working on. annotate annotate generates a schema of the model and places it on top of the model. It can also place it on top of your rspec files and the factories. It looks like this: # == Schema Information # # Table name: bugs # # id :integer not null, primary key # name :string(255) # bz_id :string(255) # fedora_rpm_id :integer # is_review :boolean # created_at :datetime # updated_at :datetime # last_updated :string(255) # is_open :boolean # Testing stack There is a ton of useful tools out there and if you are new to rails development you can easilly get lost. Rails has Two Default Stacks is a nice read that sums it up. I will try to update this post as I find more useful tools in my way. rspec I am mostly in favor of rspec because of its descriptive language and the great support by other complement testing tools. capybara So, why capybara and not cucumber? I'm not an expert on neither of these tools but from my understanding capybara is more focused on developers whereas cucumber's human language mostly targets aplications where one talks to a non-technical customer. guard Guard watches files and runs a command after a file is modified. This allows you to automatically run tests in the background, restart your development server, reload the browser, and more. It has nearly 200 plugins which provide different options as guard is not only used for testing. The particular plugin for rspec is guard-rspec . When you make the smallest change to a test and you hit save, guard will run that particular test group again to see if it still passes. I tend to invoke guard with guard -c which runs the tests in a clear console every time. Read the guard wiki page which is comprehensive and also watch the [guard railscast][] to better understand it. Other super useful tools ctags Quoting from What is ctags? : Ctags generates an index (or tag) file of language objects found in source files that allows these items to be quickly and easily located by a text editor or other utility. There are a bunch of different tools to create a tags file, but the most common implementation is exuberant ctags which we will use. It supports 41 programming languages and a handful of editors. directories Installation Install ctags via your package manager. It should be supported in all major ditributions. Configuration For a rails project, in your application root directory you can run: ctags -R --exclude=.git --exclude=log * This searches recursively all files in the current directory, excludes the .git and log directories and creates a tags file under current dir. You may want to add it to .gitignore by the way. Next, adding the following line to ~/.vimrc : set tags=./tags; sets the location of the tags file, which is relative to the current directory. You can move the above options in ~/.ctags , so in our case this will be: --recurse=yes --tag-relative=yes --exclude=.git --exclude=log So in future runs of ctags all you need to do is ctags * . ctags doesn't autogenerate, so each time you write code that is tagable, you have to run the command again. If you are working in a git repository be sure to checkout Tim Pope's Effortless Ctags with Git . What this does is: Any new repositories you create or clone will be immediately indexed with Ctags and set up to re-index every time you check out, commit, merge, or rebase. Basically, you'll never have to manually run Ctags on a Git repository again. Usage Say we have a file containing hundrends of lines. Inside a method you see the below definition: def contain_multiple_methods method_one method_two method_three end While you could search for these methods, you can save a few keystrokes by simply getting the cursor on the line of the method to search and in vim normal mode press Ctrl + ] (control and right square bracket). This should get you where the method is. Go back to where you were by pressing Ctrl + t . Note: The usage of ctags isn't restricted only in the current file. If a method in your file is inherited by another class, then searching for it will jump in this particular file. Secret power Wouldn't it be cool if we could search for methods in the Rails source code? Here is where the power of ctags really excels. All you have to do is tell ctags to also tag the rails source code. First I cloned the rails repository into vendor/rails : git clone https://github.com/rails/rails.git vendor/rails It should take less than a minute to download. You wouldn't want the rails source code to be included in your git tree, so you simply exclude vendor/rails by adding it to .gitignore . Lastly, create again the tags with ctags * . Now navigate with vim to one of your models that has for example the association has_many , place the cursor on it (or just on the same line) and hit Ctrl + ] . Pretty cool huh? In case you forgot, go back to where you were with Ctrl + t . ack ack is like grep but on steroids. Designed for programmers with large heterogeneous trees of source code, ack is written purely in portable Perl 5 and takes advantage of the power of Perl's regular expressions. It supports multiple types which you can see by typong ack --help-types . Of course there is a vim plugin ! alternative (ag) While reading the more-tools page of ack I found out about ag , also called the_silver_searcher. It is said to search code about 3–5× faster than ack, is written in C and have some more enhancements than ack. You may want to give this a try to. And as you have guessed there is also an ag vim plugin . Conclusion The editor of choice and the tools you use in web development play a great role in one's productivity, so you have to choose wisely and spend some time to get to know it. Personally, I learned a lot more these past days I was crafting this post and I hope you got something out of it too :)","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/ruby-on-rails-development-tools","title":"Rails development tools"},{"text":"I decided to drop the GSoC related titles and focus on the things that I work during the week. That means I'll probably blog more often :p This week I mostly focused on cleaning the code of fedoraruby and conforming to the ruby / rails community guidelines. The gem that helps you do that is rubocop and is kind of the standard method in the ruby world. RuboCop HoundCI RuboCop Rubocop refers to each check as a cop. There are a bunch and you can see the supported ones by reading these [files][rubo-enabled]. After installing rubocop, call it with the rubocop command and it will check all Ruby source files in the current directory. If working on a Rails project, you have to invoke it with the -R flag. The first time I ran rubocop I was presented with no more or less 666 violations. Which meant if I wanted to clean up the code I'd had to manually edit all 666 of them. Luckily, as you may have imagined, rubocop provides the -a/--auto-correct flag which does what it says. In the documentation there is a note: Experimental - use with caution . What the heck, I had nothing to lose, I am under version control so I could go back any time. It worked like a charm and this brought the violations to about 150 . Not bad at all. So what about the rest? Well, you have to do it manually and so I began. If you run rubocop without any flags, it uses the default config that ships with the gem. If you want to use your config you can do so by defining it with the -c flag. Now, there is another cool feature rubocop provides. It can create a config file for you containing all the violations found so far. Run rubocop with the --auto-gen-config flag and that will create .rubocop_todo_yml in the current dir. Then you can check against that file with rubocop -R -c .rubocop_todo_yml . All cops in this yaml file are set to false, which means they won't be taken into account, not unless you explicitly set them to true. That way you can work your way up in fixing all violations by enabling one cop at a time. Basically what is included in this file, overrides the default values. If you want to omit calling on .rubocop_todo_yml every single time, place this in .rubocop.yml : inherit_from: .rubocop_todo.yml Form now on you can just call it with rubocop -R . To sum up, run rubocop -R see that there is no violation, edit .rubocop_todo_yml , set one of the cops to true, run rubocop again, fix the errors and work your way up until there is no violation. Of course all of these are optional steps. Ruby's interpreter doesn't care about identation, it won't complain if you run a method 20 lines long and it won't throw an error if you have chain 16 methods spanning to 300 chars. All these are conventions among the Ruby community and you are not compelled to follow them. BUT, it provides much cleaner code and when you find yourself contributing to a project, all these will probably matter. In my case, you can see through this commit what changed and in this gist you can see the difference from before/after running rubocop. Dropped to 73 violations from 666. I've skipped some of them as I didn't see fit, like commenting above every class what it does. I'm not saying this isn't good to have it's just it also includes migrations and I'd like to avoid that. Also some code will be deprecated/rewritten any time soon so it doesn't make sense to fix the violations if I'm to remove the code afterwards. HoundCI Rubocop is good to test locally, but what about the code you host remotely? Enter Houndci . Houndci is a web app written in Rails by Thoughtbot that integrates with your github account. It checks for violations every time a Pull Request is submited against your repository. It relies on the rubocop gem, but it may follow different approaches than rubocop. I almost spent a day to find this out. I'll tell you what I mean since there was a particular error that made me search for many hours. Let's start by saying that it is common practice to not have lines spanning on more that 80 characters. Python has it pinned to 79. In rubocop, there is a cop that checks for method chaining. When the line is too long you should break it down, so this cop checks whether the dot( . ) that chains two methods is placed before or after the methods. Here's an example to better visualize it: def method_with_arguments ( argument_one , argument_two ) a_really_long_line_that_is_broken_up_over_multiple_lines_and . subsequent_lines_are_indented_and . each_method_lives_on_its_own_line end When I ran rubocop locally it complained with Place the . on the next line, together with the method name. Ok I did that and pushed. Then why was houndci told me otherwise ? Digging in rubocop's default config file I found that this particular cop was invoking an additional parameter: EnforcedStyle: leading . Interesting, so why houndci was telling me the opposite? Digging some more, this time in rubocop's source code, I found the responsible method . It seems rubocop gives you the option to decide which style fits you better and from what I've seen so far, houndci prefered the trailing dot. Ok let's fix that. Reading the configuration guide, and since houndci uses rubocop, I copied .rubocop_todo_yml to .hound.yml . There, following the config file I appended Style/DotPosition: EnforcedStyle: leading Enabled: true in .hound.yml , pushed the change to my repo and created a test pull request to check if it worked. No... but whyyyy?? After some more more digging, this time at the issue tracker of houndci, I finally found the culprit . The latest version of rubocop changed the way cops are presented and that broke compatibility with houndci. Back to .hound.yml I removed Style/ and pushed to github. Finally, this time it was fixed. Not much of a story, probably you already got bored or didn't make it this far, but anyway. Onto more interesting stuff, until next time it is.","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/rubocop-to-the-rescue","title":"Rubocop to the rescue!"},{"text":"Testing, testing, testing. Diving into BDD for the first time can be a little tedious but you sure learn a lot. In the ruby/rails world there is a ton of excellent tools to help you test your app. Some more popular than the others. I'm no exception so I picked what the majority of the community dictated. Testing tools Rspec The Rspec test suite is well established among ruby developers and has a big community to support it. You can also find many good books about it. One that I highly recommend is Everyday Rails Testing with RSpec . It basically includes all the tools I'll be using, I'm a little biased I admit it but it is really worth it. Here are the specs that will be populated with tests over time. models ├── bug_spec.rb ├── build_spec.rb ├── dependency_spec.rb ├── fedora_rpm_spec.rb ├── rpm_version_spec.rb └── ruby_gem_spec.rb Currently, I have worked only on bug_spec.rb which is finished for the time being. # app/spec/models/bug_spec.rb # # == Schema Information # # Table name: bugs # # id :integer not null, primary key # name :string(255) # bz_id :string(255) # fedora_rpm_id :integer # is_review :boolean # created_at :datetime # updated_at :datetime # last_updated :string(255) # is_open :boolean # require 'rails_helper' describe Bug do it 'has valid factory' do expect ( create ( :bug )) . to be_valid end before ( :all ) do @bug = create ( :bug ) @bugzilla_url = 'https://bugzilla.redhat.com/show_bug.cgi?id=' end it 'has valid bugzilla url' do expect ( @bug . url ) . to match ( / #{ Regexp . quote ( @bugzilla_url ) } \\d+/ ) end it 'is a Review Request' do expect ( @bug . is_review ) . to eq true end it 'is open' do expect ( @bug . is_open ) . to eq true end it 'is closed' do @bug . is_open = false expect ( @bug . is_open ) . to eq false end end Here I'm using the new rspec method expect(object).to instead of the old one object.should . In the validation of the bugzilla url I wanted to test against a regular expression that would return the bug url and bug number. At first I used /#{@bugzilla_url}\\d+/ but that was interpreted into /https:\\/\\/bugzilla.redhat.com\\/show_bug.cgi?id=\\d+/ . So, the slashes where treated as regexp wildcards. The trick I learned is to enclose the string into Regexp.quote(str) . This method escapes any characters that would otherwise have special meaning 1 . FactoryGirl FactoryGirl is a replacement for fixtures, Rails' default way of creating test data. In my first attempt I used it to create a Bug object. # app/spec/factories/bugs.rb FactoryGirl . define do factory :bug do | b | b . bz_id '12345' b . is_review true b . is_open true end end So, when I call create(:bug) in my bug_spec.rb it automatically creates a new Bug object in the database with the predefined attributes I gave it in the factory file. I could probably use build(:bug) instead of create and that would simply create the object but not save it in the database. This could get a lot better since it takes 2.2 seconds to just run 5 tests. Refactoring will come later, I'll primarily focus on making enough tests to cover as many edge cases as I can find. Cucumber/capybara So far I talked about unit testing. When it comes to integration testing, that is how the application as a whole behaves, there is cucumber and capybara . I haven't actually used any of these two yet. Cucumber is known for its descriptive language and better used when one works with a non-programmer product owner that doesn't want to look at a lot of code 2 . I'll probably just go with capybara. Setting a Rails development environment I spent quite a lot of time to find the proper gems and configuration to have a nice setup. This will do for an article of its own so I won't go into details. TODOs Except for preparing the test suite, I'm also into cleaning the code where possible and necessary. There are some functions that need removing, but I have to do it carefully, don't want to break anything and without tests I cannot be 100% sure. So far I have used the rubocop gem with some interesting findings (exactly 666 warnings/errors). I will talk about it next week. Now go and watch the Number of the beast . http://ruby-doc.org/core-2.1.2/Regexp.html#method-c-quote ↩ Quote taken from Everyday Rails Testing with RSpec ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/gsoc2014-week-three","title":"GSoC-2014 isitfedoraruby - Week 3"},{"text":"Here's what I've been doing last week. Previous week Architecture analysis Getting to know an app from the ground up takes some time, especially if that's a framework you are not too familiar with. Luckilly, I found the railroady gem that helped me visualize how the app is structured, you can find the results here (click on one of them and see them as raw). Deploy to a testing server Heroku might be a nice option, but their plans were limiting the database rows. Instead, I spawned a Fedora 20 droplet in digitalocean and deployed it there. I used postgres as a database backend, unicorn serving the app and nginx as a reverse proxy. First of all, I had to enable SELinux , I had to, it was off by default. Then I changed a boolean to make nginx work: setsebool -P httpd_can_network_connect on Started fixing bugs I keep finding small bugs that I currently keep track in my trello board. There is currently a discussion to move isitfedoraruby to a more general namespace, so until then I'm working on my fork and the trello board. This week Setting up rspec As this is the primary testing tool, I have started writing the first scenarios and along the way I'll be adding the actual tests.","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/gsoc2014-week-two","title":"GSoC-2014 isitfedoraruby - Week 2"},{"text":"In case you haven't heard, I have been accepted again this year for Google Summer of Code :) This time I will be working on enhancing a Rails app that provides information about the state of rubygem packaging in Fedora. isitfedoraruby is a project that was crafted in GSoC 2012 by Zuhao Wan . I will pick it where he left off and add some new features that will hopefully make us packagers' life easier. You can read my proposal here . Why I got involved in this project Project details What we have so far General info pages Single rubygem page Singe fedorarpm page Features to be added and bugs fixed Test suite Enhance the gemfile tool Show the packaging progress of a gem Enhance dependency checker UI/UX enhancements Add pages providing more general info Documentation on contributing Progress of previous week Deploy on staging server Note bugs that need fixing What's on this week Architecture analysis Setup a proper dev/test environment Fix bugs found in first week The end (for now) Why I got involved in this project Last year was the first time I took part in GSoC, first time I got involved in Fedora, first time I started contributing to GitLab. I am now a packager, still trying to package GitLab for Fedora/RHEL (help needed!) and a member of GitLab's community core-team . I even became an apprentice to Fedora's infra team (although I haven't dedicated much time admittedly). So, having packaged a bunch of rubygems already, I have stumbled upon many cases where my packager's life would be easier if I had some tools to work with. And this is where isitfedoraruby comes in. As a rails app, it looked like the perfect opportunity to learn about the framework and make something that the Fedora Ruby community could use on a daily basis when packaging. Project details As I wrote earlier isitfedoraruby is a rails app used mostly internally in Fedora by ruby packagers. The source code is hosted on github , deployed on Openshift and all the info is imported using a rake task using a cron job every hour. What you see in production is using Rails 3 and ruby 1.9.3. Zuhao has already worked in porting it to Rails 4 so I'll be working on that branch. The same project was also picked by some high school students during Google's Code In program in 2012. You can read more in Mo Morsi's blog post . What we have so far Here is a brief list of the pages there are so far. General info pages Home page All rubygems All fedorarpms Contribute About Gemfile Tool Single rubygem page Link to fedorarpm Homepage url Source code url Version Total downloads Description Dependencies Singe fedorarpm page Header links Dependency Tree (using D3 js library) Timeline (chronological visualization of the bugs & version releases) Link to rubygem Link to source code url on http://pkgs.fedoraproject.org/cgit Number of git commits Up to date (yes/no) Link to maintainer link_to bubble chart page showing the packages a user owns Table of rpms owned by user link_to rpm Upstream version Rawhide version Number of git commits Description Versions table rawhide fedora 20 fedora 19 gem version Dependencies table package name (link_to fedorarpm) rawhide version f20 version f19 version upstream version Dependents table package name (link_to fedorarpm) rawhide version f20 version f19 version upstream version Bugs table ID (link_to bugzilla, striked if resolved) Bug title Review status Builds table Build ID (link_to koji url) Title (package name) Features to be added and bugs fixed Test suite The current test suite is non-existent. Some of the tools I plan to use are: rspec for testing models and controllers factory_girl for feeding tests capybara to simulate user interaction with the app For views I will use feature specs. Existing minitest tests will be replaced with rspec ones. Enhance the gemfile tool The Gemfile tool checks against a Gemfile or Gemfile.lock and shows if the gems are packaged for Fedora. In its current implementation, it basically dumps all the information in the screen, which is not too handy if you need to somehow extract this information. The functionality I want to add is: provide a better view of the output (prettier table view) ability to provide a Gemfile url and have the output on a static page like: http://isitfedoraruby/stats/gemfile?url=www.example.com/Gemfile.lock With this we could calculate how many of the gems are in Fedora repos, which brings me to another cool feature. Show the packaging progress of a gem There are times where a gem depends on other gems not yet packaged for Fedora. A cool feature would be to able to see the packaging progress of a gem. The plan is to either implement one of the two options below (or both): Query https://rubygems.org and extract information on the dependencies. Provide a yaml file with info on the gem's review request bugzilla issue, then query koji for rawhide builds and bugzilla for any Blocks issues. If we have those two values we can calculate how many dependents gems there are not yet or already packaged. I prefer the first option as with that one could see what dependencies needed prior to submitting a package for a review request. A nice progress bar with the percentage of gem packaging completion will be provided as well. For each gem that gets in rawhide, the progress bar gets a little further. There can also be a number of other cool info in the page, like links to bugzilla requests so that someone could lend a hand, etc. At first I will focus on implementing this for a single gem but later it can be extended to track the progress of a rails app. That functionality will mainly come from the next feature in the list. Enter dependency checker. Enhance dependency checker The current representation of a gem's dependencies is in a tree format, not very handy if you want to extract information. Influenced by https://www.gemlou.pe , I plan to implement a similar representation and show the dependencies in a more elaborate way. UI/UX enhancements The app uses bootstrap as a frontend framework, as you could tell. The idea is to make it more user friendly and prettier. If it were me I would have used foundation in the first place. Upstream provides even a gem for immediate use in rails apps. In my opinion it's targeting more to developers that don't want to get too messy with css. For the time being I don't consider changing frameworks, but it's a food for thought. Add pages providing more general info Pages that would help the user experience are: list of gems pending review list of gems already assigned but stagnated for too long list of gems pending review and marked as NEEDSPONSOR All these can be queried from bugzilla through the ruby-bugzilla gem. Documentation on contributing Last but certainly not least, I will document the development contribution process should anyone want to provide any fixes/features. Apart from developing the app, I will provide a page with comprehensive steps on packaging a rubygem. A draft article can be found here . Progress of previous week I have been reading the codebase to get familiar with it and then done a few minor things. Deploy on staging server Currently I run it on heroku , but the database exceeded the free plan they provide so I'll have to move it elsewhere. I haven't yet imported the gems as the rake tasks pull in all gems from rubygems.org and the database gets huge. This is noted to be fixed in the rake task. Also, what you see is the next version of the app using Rails 4 :) Note bugs that need fixing Like last year, I will be documenting any progress in a trello board . In the code clean up list you can see what is marked as to be fixed. If you have any comments please do leave them on the cards. What's on this week We are already in the middle of the second week, so here's a preview of what I'm working on. Architecture analysis The code needs a clean up and the only way to do this is to do an analysis of the app's architecture. That will give me an overview of the changes need to be done like merging the rubygem page view into fedorarpm. Setup a proper dev/test environment Right now, if anyone wanted to play with the app, apart from db migration you would have to run the rake tasks that import all the info needed in order to have a functional app. Rather than importing each gem (which can be done in batches), I would like to create some fake data to begin with. This would help me afterwards with the tests. Fix bugs found in first week I'll try to apply fixes to as many bugs as possible I found previous week. The end (for now) Soo, that's it for now! Hope you made it this far :) Cheers to an interesting summer!","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/gsoc2014-week-one","title":"GSoC-2014 isitfedoraruby - Week 1"},{"text":"Seems there is an issue floating around when a user tries to push on their GitLab CentOS installation. There are two ways one can push to a git repo. Using their username:password through http and using their ssh key without the need of a password. For example: git push http://centos.local/axil/git.git master will prompt for the GitLab username:password whereas git push git@centos.local:axil/git.git master will push to the repo without the need of a password just using the ssh key I uploaded using the GitLab interface. Note: Pushing via ssh usually requires that you have set up properly your .ssh/config for the user you are pushing from. Mine entry for example looks like: Host centos.local User axil Hostname centos.local PreferredAuthentications publickey IdentityFile /home/axil/.ssh/id_rsa If you have installed GitLab on CentOS/RHEL, you may not be able to push via ssh and the reason is the restrictions SELinux has on /home/git/.ssh/ directory. In order to fix this problem, simply run as root: restorecron -Rv /home/git/.ssh/ You can read more here . The above fix has already taken its way upstream in the CentOS guide at the gitlab-recipes repo. If you find any other issues you are welcome to submit them in the bug tracker.","tags":"opensource","loc":"http://axilleas.me/en/blog/2014/centos-gitlab-asks-for-password-on-git-push","title":"GitLab on CentOS asks for password when using git push via ssh"},{"text":"I remember when I was trying to install GitLab 2.0 with no prior knowledge of the rails framework and ruby in general, just copy pasting commands. It seemed fun and when the login screen showed for the first time, it felt really great! And then I remember searching for the default username/password. It wasn't documented, rather than shown somewhere between the commands I was blindly copying. Since then a lot has changed, the documentation got a lot better, the community has grown big and GitLab took the way it deserved. In my last post I wrote that I would review the new book that Jonathan M. Hethey wrote about GitLab. Without further ado, let's have a look what this book offers, what not and what I would like to see included in its next version. Chapters Kickstarting with GitLab Installation Configuring GitLab Roles and permissions Issues and wiki Workflows Updating GitLab Help and Community To sum up Chapters Kickstarting with GitLab The first chapter describes the features of GitLab, points to the cloud-based solution offered by GitLab.com and refers to its competitors (open source or closed source). If you have never heard about GitLab before, this will get you started. Installation As you'd have guessed, the installation guide is there to follow, sticking as possible to the original one written by the GitLab devs. Unfortunately for the readers, since GitLab is evolving rapidly, it is only common for this chapter not to be completely up to date with the one upstream provides. My advice is, if you decide to install GitLab, you should follow the official guide and consult this book to better understand what ecah command does. Configuring GitLab Again, the configuration steps come mainly from the installation guide but are more coprehensive and better explained so you'll get a good understanding why you do what you do. You will be also introduced to the ssh protocol and learn how you can add more protection to your the server by changing the default port sshd listens to, as well as how to configure this to play well with GitLab. If you are new to the UNIX world and were blindly typing commands before, this chapter will help you grasp the reasoning behind each command. Roles and permissions As stated in the book, where GitLab excels is its intuitive web UI tied with Git and the different management user roles it provides. In this book you will learn in depth about this feature. Every role is explained extensively, with examples where possible. Also you will learn how to log in for the first time, how to create your personal ssh key, how to add new users manually through the administrative interface and how to enable sign up. Issues and wiki One other aspect of GitLab that makes it ideal for collaborating is its embedded issue tracker and the wiki it provides. Being part of a team, you will want to make code reviews, exchange ideas and document your software. The \"Issues and wiki\" chapter will help you grasp those ideas and also learn some \"hidden\" functionalities like the ability to refer to other elements inside GitLab through shortcodes (issues, Merge Requests, snippets, milestones, commit messages, etc.). Beware that there is some extensive reference to teams, a feature deprecated in newer versions and superseded by groups. Workflows In the sixth chapter you are introduced to the GitLab workflow, which if you have ever used Github, you have a pretty solid ground of understanding how it works. As I mentioned earlier, GitLab is primarily used for code review among developers and the workflow of feature branches works very well with the web UI GitLab provides, where you can create merge requests and fork projects to your own namespace. If you are not familiar with the merge request term, you will learn all about it through this chapter. The idea of Git hooks is also introduced and an example is provided for better understanding. Unfortunately there is no reference to web hooks, a feature that lacks documentation and used by many users. I would really like to see a section about web hooks in a future edition of this book. Updating GitLab Since GitLab is a rapid developed project and a new version comes out each month, you will need to know how to update it. The 3-step golden rule, backup, backup and backup applies here as well, particularly if you are an administrator dealing with a corporate environment with many projects and users. In the \"Updating GitLab\" chapter you are presented with some common backup options like tar and mysqldump , and you will learn how to first ensure a proper backup is taken and then update you GitLab Installation. As the author states, when updating you should always watch out for the current update guides available at the official repository. A nice chapter overall that learns you the importance of, what else, backup. Help and Community In the last chapter you will learn the various channels where you can get help. Basically it's a somewhat more detailed version of the Getting Help section of the README file. To sum up Overall, this book is a great starting point for newcomers to the GitLab world that have little or no prior knowledge of the git workflow. For administrators that want to install and use GitLab in their organization, it's also a good starting point and a detailed reference for the main functionalities GitLab provides. Given its daily development, sections as \"Installation\" and \"Update\" should not be taken literally, as the upstream guides are more accurate and up to date. Personally, I expected it to have more information for administrators that already know their way in using the interface. Things like ldap configuration setup of other omniauth providers usage of webhooks communicating with the api are some of the advanced functionalities I would like to have seen. Hopefully in a newer version these will be provided. If I were to grade this book I would give it a 7/10. Not at all bad, but not exceeding my expectations. I hope Jonathan will take these considerations into account and update the book sometime soon :) In the meantime go grab yourself a copy !","tags":"reviews","loc":"http://axilleas.me/en/blog/2014/gitlab-repository-management-book-review","title":"GitLab repository management book review"},{"text":"If you don't already know it, Jonathan M. Hethey has recently published a book about GitLab on packtpub. I am in the process of reviewing it, so wait for a new post very soon :) I'll attach the preface so you can get a glimpse of what the book covers. In this book, we will take a tour of the version control system GitLab, which is based on Git. It's open source and has many great features that we will learn chapter wise as listed here. First, we will take a look at what GitLab can do for us, and later we will see how we can install it on a server and configure it to match our needs. The next step is to take a close look at the web interface, and then we will learn how to handle permissions and teams, document our code, track issues, and show example workflows. Lastly, we will learn how to perform maintenance for our installation, including the creation of backups and upgrading to the most recent version. We will also cover getting in touch with the community and developers on the respective channels. Btw, there is a limited offer on packtpub untill this Friday 3rd January, so you can grab an e-book copy for only $5.","tags":"reviews","loc":"http://axilleas.me/en/blog/2013/coming-soon-book-review-gitlab-repository-management","title":"Coming soon book review - GitLab repository management"},{"text":"So far, I managed to deploy GitLab on a Fedora 19 machine using only packaged gems either from the official repos or a custom one I have created. Below you will find some more info as well as the url of the testing environment. You can use/test it and report any issues here . If anyone needs an admin account for further testing just let me know. Just bare in mind that you might see some 500 errors as I will be trying some things. More or less, here is the workflow I followed: Set up GitLab in a VM following the official installation guide and test everything works rm -rf /vendor/bundle Test with bundle install --local RAILS_ENV=production See the dependency differences Install with yum the gems in Gemfile Replace in Gemfile/Gemfile.lock with Fedora versions Repeat steps 3,4,5,6 For details on what is replaced see this Gemfile.lock.diff . The systemd services I used can be found here . There are a lot to be done yet until this reaches to the official repos but that's a start. TODO Short term Write the gitlab.spec that will glue all the dependencies together Long term Commit as many specs as possible to BZ. GitLab forks: one option is to patch upstream with GitLab's changes. Second but rather avoided is to to ask FPC for an exception and package the forks as they are. Coordinate efforts with Debian ruby team ( related discussion ) Deploy on rawhide: when GitLab supports rails 4. That depends on many dependencies gems as well. Longer term port to EPEL","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-11-and-12","title":"GSoC - Weekly update 11 and 12"},{"text":"It appears that the new bundler 1.4.0 will support parallel gem installation. Thanks to thoughtbot's post that brought that to my attention :) Now, since I've been dealing daily with GitLab for the past four months, I thought it would be a good candidate for testing. I tried it on my production server which is a QEMU VM machine. Here are the specs 1 : Operating System : Debian 7 Linux kernel : 3.2.0-4-amd64 RAM : 4GB CPU : 4-cores On to the installation of bundler's pre version: gem install bundler --pre Next step the actual benchmarking. Make sure you either perform a new GitLab installation or remove the vendor/bundle/ directory. I used the same command the official installation suggests: RAILS_ENV=production bundle install --without postgres development test aws and I kept track of the output of four different numbers of jobs to run in parallel. As you'll see, the recommended option is to use as many jobs as your cpu cores. Next table depicts the difference in gem installation time which is pretty impressive. #jobs time % difference 1 (default) 281.91s user 47.21s system 39% cpu 13:43.34 total - 4 286.28s user 48.60s system 104% cpu 5:20.65 total 61 % 8 267.65s user 43.41s system 128% cpu 4:01.71 total 71 % 12 262.71s user 42.90s system 136% cpu 3:43.31 total 73 % 16 256.37s user 41.47s system 139% cpu 3:34.05 total 74 % See full /proc/cpuinfo in this gist . ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gitlab-gem-install-benchmarking-with-bundler-14","title":"GitLab gem install benchmarking with bundler 1.4"},{"text":"I've been busy the past two weeks with some personal stuff so I got a little behind. Here's what happened in the GitLab front. Finish packaging remaining gems GitLab deploy Coordinate packaging with Debian TODO Finish packaging remaining gems Now, all (hopefully) runtime dependencies are packaged and pushed in my public gitlab-repo . The majority of them are not ready for official submission in Bugzilla, but I kept track of those that pass the standards in order to be submitted. Unfortunately they are only 5... escape_utils http_parser.rb modernizr yajl-ruby (already submitted https://bugzilla.redhat.com/show_bug.cgi?id=823351) settingslogic stamp For now I have also packaged the forks as they need some more work to be accepted in Fedora. Here I have pointed out their differences with original gems. GitLab deploy I deployed GitLab in Fedora 19 on a VPS following the standard installation, meaning all gems are bundled under vendor/bundle/ . You can visit it, but it may not be functional as I am now in the process of replacing the bundled gems with the system ones. Expect more info on this in a following post. Coordinate packaging with Debian In other news, I found out that Debian is also in the process of packaging GitLab, so I contacted them through their Ruby ML regarding this. If you follow the discussion you will understand that the main problem for them is also how to package the forked gems. Hopefully we will come to a solution. TODO Build dummy gitlab.spec with all runtime Requires for easy test install Use bundle install --local and progressively test the required gems","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-9-and-10","title":"GSoC - Weekly update 9 and 10"},{"text":"The installation of GitLab in Fedora 19 went fine. I followed the official installation guide with some deviations where necessary, mostly taken from the CentOS guide in gitlab-recipes . I setup nginx using the ssl config , and poked some holes in iptables . For systemd services I used these files . So, everything is set, configuration tests pass, services are started, nginx is started and I finally point firefox to my FQDN (which by the way is fedora.axilleas.me, no secret) just to see a big fat 502 Bad Gateway . As wikipedia suggests : 502 Bad Gateway The server was acting as a gateway or proxy and received an invalid response from the upstream server. Spot on! The server (nginx) is acting as a proxy and received an invalid response from the upstream server (unicorn). But what was that invalid response? I could reach ip_addr:8080 at which unicorn was listening, but not through my fqdn which nginx was serving. So there clearly was something wrong with nginx. Error hunting Nginx SELinux you crafty little blocker Create a custom SELinux policy module Add nginx to git group TL;DR Integration of SELinux error messages with journald Error hunting So the first thing when such an error occurs is to look through the logs. Nginx In /var/log/nginx/gitlab_error.log I could see this error repeating: 2013/08/26 21:43:01 [crit] 2597#0: *50 connect() to unix:/home/git/gitlab/tmp/sockets/gitlab.socket failed (13: Permission denied) while connecting to upstream, client 12.34.56.78, server: fedora.axilleas.me, request: \"GET /users/sign_in HTTP/1.1\", upstream: \"http://unix:/home/git/gitlab/tmp/sockets/gitlab.socket:/users/sign_in\", host: \"fedora.axilleas.me\" So we got a permission denied while nginx is trying to connect to the unix socket of GitLab. After some hours searching and reading answers in stackoverflow, it sroke to me to check whether SELinux is to blame. I set it to permissive mode with setenforce 0 and voila, nginx was suddenly recieving requests. SELinux you crafty little blocker I remembered the awesome introductory guide of SELinux at CentOS wiki, which I had used when rewriting the CentOS installation guide for GitLab and immediately started reading. By default, SELinux log messages are written to /var/log/audit/audit.log via the Linux Auditing System auditd . If the auditd daemon is not running, then messages are written to /var/log/messages . SELinux log messages are labeled with the AVC keyword so that they might be easily filtered from other messages, as with grep . So, by greping nginx in /var/log/audit/audit.log I found those relative AVC messages, which indicate indeed a denial of nginx connection to gitlab.socket . type=AVC msg=audit(1377542938.307:248364): avc: denied { write } for pid=2597 comm=\"nginx\" name=\"gitlab.socket\" dev=\"vda1\" ino=1180273 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:httpd_sys_content_t:s0 tclass=sock_file type=AVC msg=audit(1377542938.307:248364): avc: denied { connectto } for pid=2597 comm=\"nginx\" path=\"/home/git/gitlab/tmp/sockets/gitlab.socket\" scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:system_r:initrc_t:s0 tclass=unix_stream_socket Using a tool called audit2allow we are able to clear the AVC messages. If you haven't got it installed, it is shipped with the policycoreutils-devel package. grep nginx /var/log/audit/audit.log | audit2allow and the result is: # ============= httpd_t ============== # !!!! This avc is allowed in the current policy allow httpd_t http_cache_port_t :tcp_socket name_connect ; # !!!! This avc is allowed in the current policy allow httpd_t httpd_log_t :file setattr ; # !!!! This avc is allowed in the current policy allow httpd_t httpd_sys_content_t :sock_file write ; # !!!! This avc is allowed in the current policy allow httpd_t initrc_t :unix_stream_socket connectto ; # !!!! This avc is allowed in the current policy allow httpd_t user_home_dir_t :dir search ; # !!!! This avc is allowed in the current policy allow httpd_t user_home_t :dir { search getattr } ; # !!!! This avc is allowed in the current policy allow httpd_t user_home_t :sock_file write ; # !!!! This avc is allowed in the current policy allow httpd_t var_run_t :file { read write } ; These are the policies that should be used with SELinux. Notice that user_home is essential since GitLab's APP_ROOT is in /home/git/ . Similarly, you notice a policy related to the denied socket connection: unix_stream_socket connectto . Create a custom SELinux policy module After all the investigation we are closer to the solution. All we have to do is use audit2allow to generate a set of policy rules that would allow the required actions. We can generate a local nginx Type Enforcement policy file (nginx.te): grep nginx / var / log / audit / audit .log | audit2allow -m nginx > nginx .te cat nginx .te module nginx 1 .0 ; require { type var_run_t ; type user_home_dir_t ; type httpd_log_t ; type httpd_t ; type user_home_t ; type httpd_sys_content_t ; type initrc_t ; type http_cache_port_t ; class sock_file write ; class unix_stream_socket connectto ; class dir { search getattr } ; class file { read write setattr } ; class tcp_socket name_connect ; } # ============= httpd_t ============== # !!!! This avc is allowed in the current policy allow httpd_t http_cache_port_t :tcp_socket name_connect ; allow httpd_t httpd_log_t :file setattr ; allow httpd_t httpd_sys_content_t :sock_file write ; allow httpd_t initrc_t :unix_stream_socket connectto ; # !!!! This avc is allowed in the current policy allow httpd_t user_home_dir_t :dir search ; # !!!! This avc is allowed in the current policy allow httpd_t user_home_t :dir { search getattr } ; allow httpd_t user_home_t :sock_file write ; allow httpd_t var_run_t :file { read write } ; We are not done yet, as this is a file for review only. We can then go ahead and use audit2allow to make a custom policy module to allow these actions: grep nginx /var/log/audit/audit.log | audit2allow -M nginx semodule -i nginx.pp We can check the policy module loaded correctly by listing loaded modules with semodule -l . After that, remember to enable SELinux again with setenforce 1 . Add nginx to git group Unrelated to this article, but it is also needed for nginx to access the unix socket. First we add nginx to git group, and then we make sure the group that owns /home/git/ has read and execute permissions: usermod -a -G git nginx chmod g+rx /home/git/ TL;DR To fix all nginx 502 issues, as root run: yum install -y policycoreutils-{python,devel} grep nginx /var/log/audit/audit.log | audit2allow -M nginx semodule -i nginx.pp usermod -a -G git nginx chmod g+rx /home/git/ Integration of SELinux error messages with journald In a very interesting article , Dan Walsh explains how this whole process of error hunting will be much easier with Fedora 20. I urge you to read it. With the upcoming changes, the error would have appeared at systemd's status log: systemctl status nginx and the possible solutions with: journalctl -r -o verbose -u nginx.service Pretty cool, huh?","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/selinux-policy-for-nginx-and-gitlab-unix-socket-in-fedora-19","title":"SELinux policy for nginx and GitLab unix socket in Fedora 19"},{"text":"The past week or so, I have been trying to package every gem GitLab needs, in Fedora 19. This is something I should have done from the start, but better late than never. Now that I have quite learnt the rubygem packaging process, I follow a certain workflow that gets the job done pretty quickly (described below). The repo I had setup, now includes the majority of the gems needed for a working GitLab instance. Of course many of them do not pass the standards in order to submit to Bugzilla, meaning there are some gems missing the license file, the tests are not shipped or fail, etc. The only thing that is correct in all of them is the declaration of files to be incuded in the final packaged gem, that is the %files and %files doc macros. Workflow of quick packaging Notes Difficulties in gem versions TODO Workflow of quick packaging For the whole time I've been packaging gems, I use a VPS running Fedora 19. Luckily it is a pretty strong machine (4GB RAM, 4 cpu) and building a rubygem in mock takes 1-3 minutes 1 . In general, I first check in the wiki table what's missing, and then build the next gem in line. I have 2 screen windows open (among others): one pointing in ~/rpmbuild/SPECS/ and the other to ~/rpmbuild/SRPMS/ . Here are the steps onwards. On the first screen I run a simple script that downloads the gem file in ~/rpmbuild/SOURCES/ and then runs gem2rpm on it with the resulting spec saved in ~/rpmbuild/SPECS/ . I then open the spec with vim, open the url and check if the license tag is filled. If not, I check in the url for the license file. Inside vim, I save the changes with :w and run :!rpmbuild -ba % . Normally, this will fail, which is good. We need the info provided by the error: Installed (but unpackaged) file(s) found: I copy all these stuff in a temp file (I have geany open) and then I fix the %files and %files doc macro accordingly. Save and run :!rpmbuild -ba % again to check everything is in order. If the build exits with no error, I try to make the tests work. I give myself 10-15 minutes topfor each gem, as I am targeting to test the GitLab installation and not submit them to Bugzilla. Of course during the whole process, I keep track what fails and what not, so that I can come back later. You can see here my progress. After the build runs fine, I use mock to test that a package is not missing from the BuildRequires. Exit the rpmbuild screen, enter mock , which is in ~/rpmbuild/SRPMS/ , so with a simple mock rubygem-foo-1.0-1.src.rpm begins the packaging process. If something breaks, back to rpmbuild screen, adjust the spec, save it, run :!rpmbuild -bs % to just produce the srpm, exit screen, enter mock screen, run mock rubygem-foo-1.0-1.src.rpm again. And the circle goes on until I have a working rpm. When the package builds fine in mock, I copy the produced rpms in ~/repo/gitlab/fedora-19/ with cp /var/lib/mock/fedora-19-x86_64/result/*rpm ~/repos/gitlab/fedora-19 . From there, I move each package to its destined folder and using a modified script of repo_update I sync the packages to my repo hosted on fedorapeople.org. Notes Using of mock is of utter importance. Building in a clean chrooted environment, you ensure that a package builds and installs cleanly without any dependencies missing, on other machines as well. The use of the repository is two-fold. Other than the default nature of the repo where you could easily install and test GitLab, it also serves as a building point where you have packages needed by other packages and so on, that are not yet in Fedora. Sure you could use mock --init as described here , but that is quite a burden when there is a multiple dependency issue. For that purpose I made my mock default config being a copy of the fedora-19-x86_64.cfg plus the information of the fedora-gitlab.repo . sudo cp /etc/mock/fedora-19-x86_64 /etc/mock/gitlab-x86_64.cfg sudo vim /etc/mock/gitlab-x86_64.cfg Append the info of fedora-gitlab.repo (be carefull of the \"\"\" , they must be last) Repeat 1-3 for a i686 config. sudo ln -s /etc/mock/gitlab-x86_64 /etc/mock/default.cfg so that I don't have to repeatedly invoking the mock configs with the -r flag. Ultimately, gitlab-x86_64.cfg looks like this: config_opts['root'] = 'fedora-19-x86_64' config_opts['target_arch'] = 'x86_64' config_opts['legal_host_arches'] = ('x86_64',) config_opts['chroot_setup_cmd'] = 'groupinstall buildsys-build' config_opts['dist'] = 'fc19' # only useful for --resultdir variable subst config_opts['yum.conf'] = \"\"\" [main] cachedir=/var/cache/yum debuglevel=1 reposdir=/dev/null logfile=/var/log/yum.log retries=20 obsoletes=1 gpgcheck=0 assumeyes=1 syslog_ident=mock syslog_device= # repos [fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-19&arch=x86_64 failovermethod=priority [updates] name=updates mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f19&arch=x86_64 failovermethod=priority [updates-testing] name=updates-testing mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-testing-f19&arch=x86_64 failovermethod=priority enabled=0 [local] name=local baseurl=http://kojipkgs.fedoraproject.org/repos/f19-build/latest/x86_64/ cost=2000 enabled=0 [fedora-debuginfo] name=fedora-debuginfo mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-debug-19&arch=x86_64 failovermethod=priority enabled=0 [updates-debuginfo] name=updates-debuginfo mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-debug-f19&arch=x86_64 failovermethod=priority enabled=0 [updates-testing-debuginfo] name=updates-testing-debuginfo mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-testing-debug-f19&arch=x86_64 failovermethod=priority enabled=0 [fedora-gitlab] name=Unofficial GitLab repository for Fedora baseurl=http://repos.fedorapeople.org/repos/axilleas/gitlab/fedora- $ releasever / $ basearch / enabled=1 skip_if_unavailable=1 gpgcheck=0 [fedora-gitlab-noarch] name=Unofficial GitLab repository for Fedora baseurl=http://repos.fedorapeople.org/repos/axilleas/gitlab/fedora- $ releasever /noarch/ enabled=1 skip_if_unavailable=1 gpgcheck=0 [fedora-gitlab-source] name=Unofficial GitLab repository for Fedora - Source baseurl=http://repos.fedorapeople.org/repos/axilleas/gitlab/fedora- $ releasever /SRPMS enabled=0 skip_if_unavailable=1 gpgcheck=0 \"\"\" Difficulties in gem versions The most challenging aspect of my whole GSoC project is not how to package the ~ 80 gems needed for GitLab at runtime, but how to coordinate GitLab-Fedora-Upstream and their different versions of gems. In this process, there are two key stoppers that need to be resolved. For gems with versions: GitLab < Fedora, I will have to test if they properly work. Else, a gem with lower version should be packaged for Fedora. For gems with versions: GitLab > Fedora, if GitLab == Upstream, it is easy to update by asking the maintainer to update, BUT if Fedora < GitLab < Upstream , it is hard , as it is needed a version lower than the current upstream, and in Fedora we try to have the latest version. Of course that is debatable and if really needed, a gem with lower version than upstream could be submitted. TODO There are about 15 more gems to package Somehow deal with GitLab's forks Commit to github the specs i have built so far with propper commit messages Test in a gitlab-vagrant VM some new gem versions I built and submit PR with updated Gemfile Start packaging the GitLab app itself (get a clue from Gitorious) Check which gems are ok so far to submit to Bugzilla All that thanks to okeanos , a GRNET 's public cloud service which provides cloud services to the whole Greek research and academic community. More info here . ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-7-and-8","title":"GSoC - Weekly update 7 and 8"},{"text":"Here is what I have been doing the past week. Packages charlock_holmes omniauth sanitize orm_adapter Update to GitLab 5.4 Packages charlock_holmes Pending review This one gave me some headaches as it is a gem with c extensions and as it turned out I didn't ship the soname in the right directory. It took me some time but I finally understood how that works. Here are the steps I follow when packaging gems with c extensions. From the initial spec file that gem2rpm creates, comment the line below: mv % { buildroot } % { gem_instdir } /lib/shared_object.so % { buildroot } % { gem_extdir_mri } /lib/ Run rpmbuild -bi rubygem-charlock_holmes.spec in order not to remove the BUILDROOT directory. Find the soname files that get created: find ~/rpmbuild/BUILDROOT/rubygem-charlock_holmes-0.6.9.4-1.fc19.x86_64/ -name '*.so' Output ------ ~/rpmbuild/BUILDROOT/rubygem-charlock_holmes-0.6.9.4-1.fc19.x86_64/usr/share/gems/gems/charlock_holmes-0.6.9.4/ext/charlock_holmes/charlock_holmes.so ~/rpmbuild/BUILDROOT/rubygem-charlock_holmes-0.6.9.4-1.fc19.x86_64/usr/share/gems/gems/charlock_holmes-0.6.9.4/lib/charlock_holmes/charlock_holmes.so There are 2 files, one in lib/ dir and one in ext/ dir. We should ship the one in lib/ dir, so in our spec file we replace the line that we commented before with: mkdir -p % { buildroot } % { gem_extdir_mri } /lib/% { gem_name } / mv % { buildroot } % { gem_libdir } /% { gem_name } /% { gem_name } .so % { buildroot } % { gem_extdir_mri } /lib/% { gem_name } / # Remove the binary extension sources and build leftovers. rm -rf % { buildroot } /% { gem_instdir } /ext/ See what I did there? The lib dir when I used find was: ~/rpmbuild/BUILDROOT/rubygem-charlock_holmes-0.6.9.4-1.fc19.x86_64/usr/share/gems/gems/charlock_holmes-0.6.9.4/lib/charlock_holmes/charlock_holmes.so which when written with macros translates to: %{buildroot}%{gem_libdir}/%{gem_name}/%{gem_name}.so which in turn gets copied to: % { buildroot } % { gem_extdir_mri } /lib/% { gem_name } / Tl;dr; Follow the directory structure of lib/ where the soname resides and remove the ext/ . Beware that there are cases where this structure is not the same and the soname is found right in lib/ dir and not in lib/%{gem_name}/ . Take for example rubygem-pg compared to rubygem-charlock_holmes . omniauth Pending review I had some hard time with this too as it was failing the test suite. It turned out I was missing a BuildRequires dependency. A huge thanks to Ken Dreyer who pointed me out to the right direction in the mailing list as well as giving some nice tips about the packaging workflow. sanitize This was an easy one and was immediately accepted when reviewed . orm_adapter This is pending a review . Update to GitLab 5.4 I updated the dependencies to version 5.4. Overall nothing changed except for the addition of unicorn, which is already submitted for review .","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-6","title":"GSoC - Weekly update 6"},{"text":"I can't believe that a month has already passed! I keep learning new things, mostly on packaging, and the cool fact is that many of them are through my Review Requests. The discussion between the reviewer and the reviewee can sometimes be very productive leading to learning new things I previously ignored. This post would be a long one but I decided to split it up, because some sections deserved there own space. The first split is named I got approved as a packager, now what? and it refers to all new Fedora packagers :) The second one is going to talk about maintaining an unofficial repo and I will describe my workflow and the potential scripts that facilitate the whole process. And here is the rest of my progress during the fifth week. Packages How to package a Ruby gem - blog post status TODO next week Packages This is the first time that some packages of mine got approved: hashie bootstrap-sass timers I am also working on rubygem-rugged as a reviewer this time. This is much more difficult than being the reviewee, since it needs a lot testing from your side and a good understanding of the guidelines. And of course there is a bunch of other gems I am working on but not ready to submit yet. As always, my progress is noted in this trello board . How to package a Ruby gem - blog post status As you may know, I am in the process of writing an article on how to package Ruby gems in Fedora. This is the only type of package I have been dealing with for the past months, so I am far from an avid packager in general. But, as a structure and wiki freak I like to have everything in order, even understandable by completely newbies, so this is going to be very comprehensive. Progress is being made :) You can now watch the progress here . TODO next week Submit more packages Set up GitLab on a Fedora machine and check if packaged bundler works Take on reviews of packages concerning the gsoc project","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-5","title":"GSoC - Weekly update 5"},{"text":"This must have been the most intense week in terms of learning how the build system/process work in Fedora. I finally got approved as a packager and that means more responsibility from my side. Unfortunately, the instrusctions in the wiki are sometimes sparsed into different places and one has to read a lot and ask around in order not to make any mistakes. For a newcomer all this information is at least overwhelming and you have to even put a lot of thinking into asking the right question in order to get the right answer. I'm starting to believe that this is intentional as a continuous test to one's understanding of how things work in Fedora. No pain no gain they say. Anyway, I kinda managed to understand most of it and below I will describe the process I followed hoping to help any future-to-be packagers. I will describe the whole process of my first package submission including the outputs of many commands that were new to me. This wiki page sums it up, but read it after understanding the process. There is also a nice guide called packaging rpm workflow that shows the workflow of the whole process from the very beginning. Nice read. With the kind help of the people at #fedora-devel I was able to pull it through, so thanks guys :) Route to follow after your approval SCM request Commit, build and upload your package Steps with fedpkg and git Build on koji Submit your package to current versions of Fedora Push your package to bodhi FAQ Epilogue Route to follow after your approval Congratulations you promoted to a packager ! After your approval, there are a bunch of things to do, summarized into two big steps: Make a scm request in your bugzilla review request Use fedpkg to commit, build and upload your package Let's break it down. SCM request Must read: Package SCM admin requests For starters, scm stands for Source Code Management . After your package approval, there are two steps as far as the Bugzilla concerns. set fedora-cvs flag to ? Make a new comment including the following form completed: New Package SCM Request ======================= Package Name: Short Description: Owners: Branches: InitialCC: Hit Save Changes to save both 1 and 2. See how I did it. Note: Let me tell you a little secret if you are new to bugzilla like I am. Make any changes you need to, even leave a comment and then hit Save Changes to save ALL the changes you've made. There are two buttons for this: one in the upper right corner and one below the Additional Comments form. Either one will do just fine. This may sound stupid but I wansn't aware of it, so I first left a comment and then changed the flag, resulting to send a mail update twice. Commit, build and upload your package Must read: Add Package to Source Code Management (SCM) system and Set Owner After the scm request, you will receive some e-mails from Bugzilla and PackageDB stating that you are good to go. If you visit cgit you will see your bare repository. The whole building process works using fedpkg and git commands, so if you are not familiar with git, I suggest the Fedora wiki page . For a more comprehensive approach I highly recommend the Pro Git book . Steps with fedpkg and git Create a directory to have all your package builds neat and tidy. mkdir ~/fedora-scm cd ~/fedora-scm Clone the newly created git repository. fedpkg clone rubygem-bootstrap-sass cd rubygem-bootstrap-sass The contents of git config are: [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \"origin\"] url = ssh://axilleas@pkgs.fedoraproject.org/rubygem-bootstrap-sass fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master Import the src.rpm: fedpkg import /var/lib/mock/fedora-rawhide-x86_64/results/rubygem-bootstrap-sass-f20.src.rpm You should see something like this: Uploading: 4f0c887ea7cd95812edcc6b8b01b9329 bootstrap-sass-2.3.2.1.gem ######################################################################## 100.0% Uploaded and added to .gitignore: bootstrap-sass-2.3.2.1.gem ... diff status of all files to be commited ... New content staged and new sources uploaded. Commit if happy or revert with: git reset --hard HEAD Now we have 3 files in our directory: -r--r--r--. 1 axil axil 86528 Jul 20 15:30 bootstrap-sass-2.3.2.1.gem -rw-r--r--. 1 axil axil 2314 Jul 20 15:30 rubygem-bootstrap-sass.spec -rw-r--r--. 1 axil axil 61 Jul 20 15:30 sources sources is a text file with the source package (gem) and its md5 hash. Notice that the gem name was automatically placed to the .gitignore . Running git status we see that there are 3 files in the staging area . # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: .gitignore # new file: rubygem-bootstrap-sass.spec # modified: sources # If you are indeed happy with the changes, commit them and push to master (rawhide) branch. Use the bugzilla id from your review request. No scripts are parsing this, it is just for reference. git commit - m \"Initial import (#982679).\" git push Now, if you visit again the cgit web page, you will see that the changes are submitted. Build on koji Lastly, give this command to start a build on koji : fedpkg build Output: Building rubygem-bootstrap-sass-2.3.2.1-1.fc20 for rawhide Created task: 5631690 Task info: http://koji.fedoraproject.org/koji/taskinfo?taskID=5631690 Watching tasks (this may be safely interrupted)... 5631690 build (rawhide, /rubygem-bootstrap-sass:md5): open (arm02-builder11.arm.fedoraproject.org) 5631691 buildSRPMFromSCM (/rubygem-bootstrap-sass:md5): open (buildvm-25.phx2.fedoraproject.org) 5631716 buildArch (rubygem-bootstrap-sass-2.3.2.1-1.fc20.src.rpm, noarch): open (buildvm-01.phx2.fedoraproject.org) 5631691 buildSRPMFromSCM (/rubygem-bootstrap-sass:md5): open (buildvm-25.phx2.fedoraproject.org) -> closed 0 free 2 open 1 done 0 failed 5631716 buildArch (rubygem-bootstrap-sass-2.3.2.1-1.fc20.src.rpm, noarch): open (buildvm-01.phx2.fedoraproject.org) -> closed 0 free 1 open 2 done 0 failed 5631737 tagBuild (noarch): closed 5631690 build (rawhide, /rubygem-bootstrap-sass:md5): open (arm02-builder11.arm.fedoraproject.org) -> closed 0 free 0 open 4 done 0 failed 5631690 build (rawhide, /rubygem-bootstrap-sass:054f742970e4b930bc55a5d3802fb31d26c57d0d) completed successfully A notification mail will be sent to you once the build is complete and the package will appear automagically at rawhide repos. If you want to push a package to a stable version of Fedora, keep reading. Submit your package to current versions of Fedora This step is optional if you want to maintain other versions than rawhide. Switch to the corresponding version branch with fx , where x the version of Fedora: fedpkg switch-branch f19 Running git branch -r reveals our branches so far: origin/HEAD -> origin/master origin/f19 origin/master Tip: I suggest you use a shell where it shows you the branch you are in. I recommend zsh and if you look at oh-my-zsh , almost all themes included support this. Mine for example is: Get the changes from master branch, push and build like before: git merge master git push fedpkg build Push your package to bodhi If your local machine's username is the same as your FAS one, skip this step. This option is hidden from the wiki guide, I spoted it here . echo \"export BODHI_USER=axilleas >> ~/.zshrc\" source ~/.zshrc Replace .zshrc with your shell's rc. The final step is to submit your package to bodhi in order to be processed and reach the repositories. You have two options: either via terminal or via the webui of bodhi. Choose what fits you best. If you prefer the webui method then go to this link , login and fill in the blanks. There are tooltips for each section explaining what should be filled, but let's take a look: Description Option Meaning Package rubygem-bootstrap-sass Start typing your package name and it will autocomplete Type newpackage Since this is the first package I chose newpackage Request Testing For the package to first land in updates-testing before goes in stable(recommended) Bugs 982679 The bugzilla id of your review request. This way it will change its status automatically Notes Package description Additional notes, eg. why you made this update, what are the bugfixes if it is a bugfix, etc. Suggest Reboot untick Recommend that the user restart their machines after they install this update Enable karma tick Enable update request automation based on user feedback Threshold to stable 3 This is the defaul value. It needs 3 points to get to stable repos Threshold for unpushing -3 If it gets 3 points it rejects the package from testing Your other option is to do the update through terminal. This only works with branches other than rawhide. If you try to push to rawhide, fedpkg will warn you. When you issue the command below, you will have to edit a template using the default system editor which is vi . If you have a different preference eg. vim , use the export command. While in f19 branch: export EDITOR = vim fedpkg update The template is this: [ rubygem-bootstrap-sass-2.3.2.1-1.fc19 ] # bugfix, security, enhancement, newpackage (required) type = # testing, stable request = testing # Bug numbers: 1234,9876 bugs = # Description of your update notes = Here is where you give an explanation of your update. # Enable request automation based on the stable/unstable karma thresholds autokarma = True stable_karma = 3 unstable_karma = -3 # Automatically close bugs when this marked as stable close_bugs = True # Suggest that users restart after update suggest_reboot = False Once you make all the appropriate changes, save it and close it. You will be asked your FAS password to complete the process and you will get a similar output: ================================================================================ rubygem-bootstrap-sass-2.3.2.1-1.fc19 ================================================================================ Release: Fedora 19 Status: pending Type: newpackage Karma: 0 Bugs: 982679 - Review Request: rubygem-bootstrap-sass - Twitter's : Bootstrap, converted to Sass and ready to drop into : Rails or Compass Notes: Initial commit Submitter: axilleas Submitted: 2013-07-20 15:20:18 https://admin.fedoraproject.org/updates/rubygem-bootstrap-sass-2.3.2.1-1.fc19 After the submission, your package will go through these states . FAQ Here are some questions that I had during this process and their answers from people in #fedora-devel which I thank them once again. Q: During fedpkg import src.rpm , do I need to provide a foo-f20.src.rpm or foo-f19.src.rpm will work too? A: You can virtually take any valid fedora/rhel srpm regardless on which version it was created. Q: What if I accidentally run fedpkg update for rawhide (master branch)? A: New versions of fedpkg should refuse. Q: If in a package review the spec's release version was bumped, should I revert the release to 1 prior to pushing in cgit? A: No, it is not needed. Epilogue This was quite an adventure and I learned a lot. I am sure this is only the tip of the iceberg and there's a lot more to come. This post took me literally one day to compose as I was virtually recording the process as I performed it, hope it was worth it. If you find any mistake or you want to add something please do leave a comment. Next big article the Rubygem packaging How to ;) Cheers!","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/i-got-approved-as-a-packager-now-what","title":"I got approved as a packager, now what?"},{"text":"Here is what I have been doing the last two weeks. Work on packages sanitize boostrap-sass orm_adapter devise Gems and their versions in json format Version table in wiki Init repository Rubygem packaging article TODO next week Work on packages I ran gem2rpm on all gems and saved their specs in a tmp folder so that I can easily modify them later. I intend to split them in categories according to the bundled gems in GitLab's Gemfile that are needed for production. Below are some gems that are either almost ready for Bugzilla or submitted. There are a dozen more that I work with but haven't pushed any changes to github. Will do soon. sanitize Not yet submitted to BZ as it needs nokogiri 1.6.0 whereas in Fedora we still have 1.5.9. Will have to talk to the maintainer of nokogiri for an update. boostrap-sass Submitted in Bugzilla . This is a tricky one as per the package guidelines, as it ships with some javascript files that are distributed from Twitter bootstrap , which are considered a bundle. And if you don't already know it, bundling is prohibited by the packaging guidelines . You can follow the discussion in the Bugzilla. There is also an interesting discussion going on in packaging ML, about web Assets/JavaScript guidelines and are proposed some drafts . This could probably alter the packaging structure of bootstrap-sass, but I don't expect it anytime soon. orm_adapter Some tests are skipped because they require some gems not yet packaged for Fedora, but that is a little acceptable . This is a dependency of devise (see below). To be submitted soon. devise Devise provides ready-made authentication and user management for rails applications. It is a very popular rack application among the rails community, so it'll be cool to get it into Fedora's repos :) Submission is on the way along with orm_adapter. Gems and their versions in json format As I've mentioned before, one of the main problems about packaging GitLab, is the version mismatch between GitLab, Fedora and upstream gems. I have added some more functions to my script and now it saves the gems with their corresponding version in a json format. There are three files: gitlab.json , fedora.json and upstream.json . I haven't added a flag to those methods yet, so one has to run it through the python interpreter for now. Here's how: Install python-bugzilla and pkgwat.api if not already. git clone https://github.com/axilleas/gsoc.git && cd gsoc Start your python interpreter (I prefer ipython) import gemfile as g dicts = g.populate_dicts() [gitlab, fedora, upstream] = dicts It will take a couple of minutes since it uses pkgwat.api to query the Fedora database for the gems in Rawhide, and rubygems.org for the upstream versions. dicts is a tuple containing all three dictionaries. With the last command we unpacked the dictionaries of the tuple. So now calling gitlab, you have the gitlab dictionary and so on. Note: All methods are called using the runtime gems of the current version of GitLab, which are 143 for now. According to those gems we then search the Fedora package database and quering rubygems.org's API. Version table in wiki There is now a table in the wiki for an easy reference about the versions of gems. Where you see None it means it hasn't been packaged for Fedora yet. This is now automatically accomplished by running the script. Further below is a list of the gems to be packaged. Those that are submitted to Bugzilla are accompanied with a link to their review. I am working on automating this process, it should be something similar to how the wiki table is generated. Also, I modified the output a little bit to be more readable. For example: ------------------------------------------------------ Gitlab runtime gems : 143 Gems in Fedora repos : 380 Common gems : 64 To be packaged : 79 Pending review in BZ : 11 When BZ go in repos : 68 Fedora will have 20.79 % more ruby packages, that is 459 gems in total. ------------------------------------------------------ Init repository I have created a repository at fedorapeople.org to start populating it with packages I build, but take a long time to get to Fedora repos. This should be a good chance to test the packages they make it to Rawhide. Most gems come with a bundled test suite. Running tests during gem packaging can sometimes be cumbersome but it is the only way to test that the gem really works, at least according to the suite. To my experience, getting the tests run requires a big amount of your time during package building, so in this test repo expect to find many packages without their tests run. At least this is going to be the case at the beginning. Rubygem packaging article Half done, nothing commited yet, I have everything local. This takes more time than I expected, as I want it to be easily understandable by people that don't have a clue, but also a good guide for more experienced users. I am rather picky and I read what I write many times, so yeah, this is going to take longer to finish. TODO next week Categorize gems according to their dependencies. Submit 5-10 more gems. Deploy GitLab on a Fedora server and test with some packaged gems. This is going to hit me hard I feel it :p Maybe write an unofficial guide of how to install GitLab in Fedora, haven't checked if there is a guide out in the internets.","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-3-and-4","title":"GSoC - Weekly update 3 and 4"},{"text":"Unfortunately this week hasn't been very productive due to lack of time. I managed to package 5-6 more gems, but I haven't submit them in Bugzilla yet. As always, the most difficult and time consuming task is to make all the test suites provided with each gem pass. And believe me this isn't always easy. So, here is what I did this week. Meeting GitLab devs We arranged a google hangout and we talked about the progress I make. They were kind enough to ask whether I need help with something. Then I got to meet in person Sytse Sijbrandij and Marin Jankovski during Euruko 2013 . Really cool guys. Our main concern was about the gems that are GitLab's forks and how we should deal with them since it is very unlikely they get accepted into the official Fedora repos. See next week TODOs about that matter. Wikification and versioning process I started a wiki page on GitLab , listing all the dependencies and their versions. I said version s because we have to deal with version mismatch, remember ? I am working on a script to get them automatically on a table. So far, I can extract GitLab's and upstream versions whereas I still need Fedora's. Here's how I do it. GitLab gem versions are retrieved from this dictionary. Pretty simple. Upstream Using this method by qeuerying the API of rubygems.org and iterrating through the missing gems, I can get in a list of the latest gem versions. Fedora There is this nice tool in ruby called pkgwat which queries Fedora's repo database. This is also used by isitfedoraruby , which unfortunately doesn't have an API. This would make my work a lot easier. So, I decided to give this a shot by first packaging it. This is what I am learning here, isn't it? I thought this would be a matter of time since it only depends on one unpackaged gem, sanitize (which ironically is needed by GitLab too). (And I just whipped out a mosquito. Where the hell are they going 14.30 in the afternoon?...) The process that I thought would take me 30 minutes top, still goes on. You see, pkgwat has a fixed dependency on nokogiri 1.5.5 whereas the latest sanitize 2.0.4 requires nokogiri>=1.6.0 . On Fedora we have nokogiri 1.5.9 . Let me draw that for you. Welcome to Gem dependency hell. The only way to install it is through gem install pkwat ... Package review My first informal review in order to be sponsored as a packager was rubygem-rugged . I did all my homework and I tested the given SPEC and SRPM with fedora-review, I built the rpm using both mock and rpmbuild and then ran rpmlint against the produced packages. I made a few notes of what I thought needed fixing and with some help from Vit 1 I submited my review. Package submission Last week I submited for review rubygem-timers , this week it is rubygem-redis . One package a week you say? Dude are you ever going to package all these gems? Well, submiting a package for review in bugzilla takes some time, as I carefully check to follow the guidelines as much as I can. The toughest part of it all are the testing suites. A test may rely on other gems that are not in Fedora yet, so I try to package them as well. Here you will find some packages I am working on. Most of them are not submited for review yet. TODOs for next week Get more packages finished Complete the version table in wiki Start porting gemfile.py into ruby (eventually) Continue writing the article about Rubygem packaging Talk to infra team to see how that forked-gem-packaging will go I am just a placeholder, nothing useful here, I just wanted to continue the stairs I actually did seek for some help in Ruby-SIG ML :p ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-2","title":"GSoC - Weekly update 2"},{"text":"It's been over a week that GSoC started and here is a weekly report of what achieved so far. Weekly process Workflow Trello board - This is a web app in which you can manage your workflow by adding tasks that are to be completed. I set it up to remind me the things I have to accomplish in due time. Cool thing is that there is an android app too, so I can manage it from wherever I am :) First package I submitted my first package to Bugzilla for review. Yay! It is called timers and is of course a rubygem (what else :p). Not a big deal, just an easy one to get me started. List of gems to package I re-calculated GitLab's gem dependencies, this time including only the ones needed for runtime. I ditched from the list the ones that are used for testing/development. Not that they are not useful, but for the time being runtime dependencies are a priority. I used a really ugly hack but it works for now. Here is how: Clone GitLab , cd into it and run: bundle exec install --deployment --without test development This will install all deps included in the Gemfile except for the ones in test and development groups. Then, using a for loop we can iterate under the vendor/bundle/ruby/1.9.1/gems directory and write the results in a file. for i in ` ls vendor/bundle/ruby/1.9.1/gems ` ; do echo $i >> ../gitlab53-gems ; done The list contains gems in the format of gem_name-1.0.0 so I had to clean that up a little. I used some string methods in the python script and stored those values in a dictionary where key is the gem name and value its version. Then the names list was easily retrievable. All I had to do is call the keys() method on the dictionary and store the result in a file . Then, I had somehow to include in the list of already packaged gems, the ones that are submitted in bugzilla for review. No need to work on them if their specfile is already submitted for review, right? For that I used the python-bugzilla tool that queries a Bugzilla instance and spits nice formated results . The query is pretty much self explanatory. In the end I just sorted them according to their bug status. bugzilla query --product = fedora --bug_status = new,assigned --component = 'Package Review' \\ --short_desc = 'rubygem-' | sort -k2 -r > $bugzilla_gems_raw Below, using the same query methods and some sed/awk magic 1 , we end up with a file containing only the names of gems that are submitted for review in Bugzilla. bugzilla query --product = fedora --bug_status = new,assigned --component = 'Package Review' \\ --short_desc = 'rubygem-' | awk 'BEGIN { FS = \" - \" }; { print $3 }' | awk \\ 'BEGIN { FS = \":\" }; { print $2 }' | sed -e 's/rubygem-//' | sort -k1 > $bugzilla_gems That list, combined with the query from the official repos, results in the final one which has all the Ruby gems already packaged or are to be packaged for Fedora. I also wrote a method to store those values in a dictionary in the format of dict = { gem_name: [bug_id, status, assignee, description] } . It might come in handy in the future, who knows! Next step was to find the missing gems that I will have to package for Fedora. Comparing those two lists we end up with this list . And the new results are: Gitlab uses 143 runtime gems. Fedora has packaged 461 gems. There are 73 common gems. There should be packaged 70 gems. Fedora will have 15.18 % more ruby packages, that is 531 gems in total. Gem tree dependencies There are a lot of gems that depend on each other which means one has to be picky as to what to package first. The best way would be: given a package, find its dependency tree and start packaging first the leafs that have no children going all the way up until you reach to the root. I started writing a script in ruby as a way to better learn the language, but I have yet to iplement the DFS algorithm which will traverse through all dependencies. Any comments on how to best approach this are welcomed! Update!! I just found out this reaaally cool site: https://gemlou.pe which parses rubygems.org and lists the runtime tree dependencies of a gem through javascript! Article about gem packaging I started writing an article about packaging a Ruby gem in Fedora. I want to note down the whole process, beginning from the use of gem2rpm to the review process. At first I wanted to have it finished by this week, but the information is so vast that I will take my time and write it piece by piece. You can follow the process here . TODO Some TODOs for this week: Continue writing the article about Rubygem packaging Make some unofficial package reviews in order to get sponsored as a packager Make more package submissions (I have some specfiles ready) Start wikifying the process (like the Gitorious page) Extras Apart from the GSoC program that is an awesome experience, there are some other cool stuff going on this summer. First one is Euruko which will take place in Athens, so it will be easy to attend. I have already purchased a ticket. I am sure that it's gonna be awesome and I'll get to meet the GitLab devs as well :) The other one is a MOOC by UC Berkley and is a course about agile development and SaaS. It has two parts: CS169.1x starts on July 2nd and is lasting 5 weeks CS169.2x starts on August 13th and is lasting 6 weeks The language they use is Ruby and the framework on which they build the apps is Rails. I am going to attend both courses as it is strictly related to GitLab and my GSoC involvement. Actually, I already bought the accompanying book (not mandatory) and started reading it :) I will try to be more on schedule next time and post about my progress at the end of each week. Cheers! It would make matters easier if the query returned a json file. I haven't seen anything in the man page about json support. ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/gsoc-weekly-update-1","title":"GSoC - Weekly update 1"},{"text":"Use case: You have a remote machine with high bandwidth and you want to turn it in a torrent server. Prerequisites Transgui Prerequisites All you have to install in the remote server, is transmission-daemon which is pretty much included in every well known distribution. After it successfuly installs, run transmission-daemon as your user, no need for extra privileges. See the man page for extra commands. In the client side you will need Transmission Remote Gui (I will call it transgui from now on), a cool cross platform front-end to remotely control a Transmission Bit-Torrent client daemon via its RPC protocol. In Fedora you can install it from the official repos with: yum install transgui whereas in Archlinux you can find it in AUR . I suggest you go with the bin one which is a precompiled binary so that you avoid the building time. Now, there is this little bash script which makes an ssh connection to you server, in order to link transgui with transmission-daemon: #!/bin/bash RPORT = 9091 LPORT = 9092 ssh -C -c blowfish -f remotevm -L $LPORT :localhost: $RPORT -N if [ 'x' $1 == 'x' ] ; then echo \"Connection established\" else echo \"Connection failed\" fi Let's cut it down to pieces. -C is optional and it will compress all the data of the session. As the man page dictates, use it only on slow connections (client side). -c blowfish selects the cipher specification for encrypting the session, in this case blowfish . -f requests ssh to go to the background. remotevm is just an alias of the remote server I have at my ~/.ssh/config in which I use an ssh key to connect to, without using a password. -L $LPORT:localhost:$RPORT specifies that the given port on the local (client) host is to be forwarded to the given host on the remote side. Here I use RPORT for the remote side and LPORT for the local one. Note that 9091 is used by default from transmission as its bind port. All this is traversed through localhost, no external IPs. -N makes sure there isn't executed a remote command. This is useful for just forwarding ports. Transgui After you run the above script and see the Connection established message, it's time to open transgui and connect to the remote server. Make a new connection as it appears in the image below. Default username:password is transmission . If you want to change it, either pass it as a parameter when running transmission-daemon (see man page) or edit $HOME/.config/transmission-daemon/settings.json with the daemon stopped. Some more screens: The dialog that appears when you open a torrent file Main download page Now all that remains is to retrieve the downloaded data. There are numerous ways to do so, like using scp , rync , ftp , sftp , sshfs etc, each serving its own purpose.","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/connect-to-transmission-through-an-ssh-encrypted-session","title":"Connect to Transmission through an ssh encrypted session"},{"text":"Sooo, I am happy to announce that I got accepted to this year's Google Summer of Code! Couldn't be more happy right now :) For those that have no idea, here is my proposal on Fedora's wiki ( my user ). I have in mind to make a follow post on how I dealt with all this the past three months. Special thanks to John Giannelos for pressuring me to apply :p","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/accepted-for-gsoc-2013","title":"Accepted for GSoC 2013"},{"text":"Code School is an online learning platform that teaches a variety of programming and web design skills. Courses range from beginner to advanced levels and you get to earn rewards and badges as you learn. Courses cover a variety of technologies including among others Git , Ruby , Backbone.js , Sass , Rails , jQuery . Each course has a unique environment and some their own theme song, which is kinda cool. Here is the special page where you can find all these songs. Normally, there is a monthly subscription that costs only 25$ and grants you access to all courses and screencasts, with download links for the videos and the presentations. The current offer covers a 2 day free pass for all courses and screencasts. Here is my affiliate link 1 to get you started (shameless promo :p). For each person that signs up, you get two more free days until you reach a limit of 30. During this weekend I finished the Ruby Bits and Git Real courses and I have to admit I learned a lot. My next goal is the famous Rails for Zombies which I am looking forward to complete! So, what are you waiting for? Go and learn some realy cool stuff! I got an email from codeschool about this offer and there doesn't seem to be a clear url to reach it. That's why I am posting the affiliate url. ↩","tags":"news","loc":"http://axilleas.me/en/blog/2013/codeschool-two-day-hall-pass","title":"Codeschool offers 2-day hall pass to all courses"},{"text":"Update : The Popeye on Mars project came first in \"Best Mission Concept\" category. Congrats guys! During the weekend of 20th and 21st of April we gathered at hackerpace.gr and started hacking for NASA's space apps challenge. From their webpage : The International Space Apps Challenge is an international mass collaboration focused on space exploration that takes place over 48-hours in cities around the world. The event embraces collaborative problem solving with a goal of producing relevant open-source solutions to address global needs applicable to both life on Earth and life in space. NASA is leading this global collaboration along with a number of additional government collaborators and 100+ local partner organizations. 16 people, 2 teams, 2 days, 2 globally nominated projects: popeye on mars and anapNEO . See here some photos. Thank you mozilla for all the pizzas and souvlakia :) Popeye on Mars Our solution is a deployable, reusable spinach greenhouse for Mars. Internally, a fully equipped aeroponic system operates for ~45 days, having all the needed resources, sensors and electronic systems to stabilize the internal environment and help the spinach growth. Also, there are systems for harvesting produced oxygen during the process and the plants at the end of it. Externally, photovoltaic panels provide power, while several cover layers protect the system against Mars extreme conditions. Project page Video anapNEO anapNEO is a web app build on Django and HTML, CSS, JS that enables the submission and ranking of NEO findings. Focused on UX simplicity and streamlining of the registration and submission process, a user signs up easily using Persona, and creates a user account (with basic information). She then lands on a (public too!) Dashboard that displays all latest submissions and can submit a new finding. You can also vote on findings affecting the score and (yet to implement) expose those on an API. Project page Video","tags":"news","loc":"http://axilleas.me/en/blog/2013/nasa-spaceappschallenge-2013","title":"Nominated for Space Apps Challenge 2013"},{"text":"Ένα πολύ ωραίο thread σχετικά με τον vim editor βρίσκεται εδώ , όπου το μέλος imitheos έχει παραθέσει πολλά χρήσιμα tips. Στο παρόν post θα προσπαθήσω να τα συγκεντρώσω όλα μαζί. Όπως θα διαπιστώσετε είναι ΠΑΡΑ πολλά, οπότε grab a cup of coffee, open vim and start practicing! Οι συχνότερες λειτουργίες πλήκτρων Εύρος εντολών Εντολές με βάση το παρελθόν Εντολές εύρεσης Οι πιο συχνά χρησιμοποιούμενες εντολές στην κατάσταση ex Η εντολή s Η εντολή global Εκτελώντας εντολές μέσα από τον vim Ενεργοποίηση διάφορων επιλογών background (bg) hlsearch (hls) list listchars (lcs) textwidth (tw) c_space_errors Registers Marks Backreferences και Patterns Απόκρυψη (δίπλωση) πληροφοριών με την foldmethod Η εντολή colorcolumn Τοποθεσία κέρσορα Ελληνικός ορθογράφος Παράδειγμα .vimrc Credits Οι συχνότερες λειτουργίες πλήκτρων Υπάρχουν εκατοντάδες λειτουργίες πλήκτρων και ανάλογα με την κατάσταση που είμαστε το ίδιο πλήκτρο εκτελεί διαφορετική λειτουργία. Τα παρακάτω είναι τα πιο απλά και πιο συχνά χρησιμοποιούμενα. h : Μετακίνηση του δρομέα αριστερά. j : Μετακίνηση του δρομέα κάτω. k : Μετακίνηση του δρομέα πάνω. l : Μετακίνηση του δρομέρα δεξιά. i : Μας βάζει στην κατάσταση εισαγωγής με τον δρομέα πριν την υπάρχουσα θέση I : Το ίδιο με i αλλά στην αρχή της γραμμής a : Μας βάζει στην κατάσταση εισαγωγής με τον δρομέα μετά την υπάρχουσα θέση A : Το ίδιο με a αλλά στο τέλος της γραμμής ο : Μας βάζει στην κατάσταση εισαγωγής αφού αλλάξει γραμμή O : Το ίδιο με o αλλά εισάγει πριν την προηγούμενη γραμμή p : Επικόλληση των περιεχομένων του buffer μετά από τον δρομέα. r : Αντικαθιστά ένα χαρακτήρα. R : Αντικαθιστά πολλούς χαρακτήρες u : undo Ctrl+R : αναίρεση του undo (redo) y : Αντιγραφή στο buffer d : Διαγραφή x : Διαγραφή χαρακτήρα μετά τον δρομέα X : Το ίδιο με x αλλά πριν τον δρομέα D : Διαγραφή από τον δρομέα μέχρι το τέλος της γραμμής G : Μετακίνηση σε κάποια γραμμή ή στο τέλος του αρχείου J : Ενώνει την γραμμή με την επόμενη . : Εκτελεί την προηγούμενη εντολή Εύρος εντολών Πολλές εντολές δέχονται εύρος. Για παράδειγμα, αν πληκτρολογήσουμε 6x θα σβήσει 6 χαρακτήρες. Η εντολή 5G θα μας πάει στην 5η γραμμή. Οι εντολές y και d δέχονται και ένα όρισμα που δηλώνει την λειτουργία της εντολής. Τα πιο συχνά χρησιμοποιούμενα είναι w (μια λέξη), $ (μέχρι το τέλος της γραμμής) και d (μία γραμμή). Στην περίπτωση του y , αντί για το d έχουμε το y (μία γραμμή). Έτσι, έχουμε: d$ : Διαγραφή μέχρι το τέλος της γραμμής (ίδιο με D) 5dw : Διαγραφή 5 λέξεων yy : Αντιγραφή 1 γραμμής 3dd : Διαγραφή 3 γραμμών d3d : Διαγραφή 3 γραμμών Τα δύο τελευταία παραδείγματα βλέπουμε ότι κάνουν το ίδιο πράγμα ενώ έχουν διαφορετική σύνταξη. Το 3dd θα εκτελέσει τρεις φορές την εντολή dd σβήνοντας δηλαδή από μία γραμμή ενώ το d3d θα σβήσει 3 γραμμές. Εντολές με βάση το παρελθόν Άλλες εντολές μετακίνησης που χρησιμοποιούνται συχνά και έχουν βάση στο παρελθόν είναι: Ctrl + B : Μια σελίδα πίσω Ctrl + F : Μια σελίδα μπροστά &#94; : Μετακίνηση στην αρχή της γραμμής $ : Μετακίνηση στο τέλος της γραμμής w : Μετακίνηση μια λέξη μπροστά b : Μετακίνηση μια λέξη πίσω Και αυτές παίρνουν ορίσματα εύρους π.χ 5$ Εντολές εύρεσης / : Εύρεση προς τα κάτω του ορίσματος που θέλουμε ? : Εύρεση προς τα πάνω n : Εύρεση του επόμενου αποτελέσματος του / ή ? N : Εύρεση του επόμενου αποτελέσματος στην αντίθετη κατεύθυνση Αυτές οι εντολές χρησιμοποιούνται στην κατάσταση εντολών (command mode). Οι πιο συχνά χρησιμοποιούμενες εντολές στην κατάσταση ex Αν στην κατάσταση εντολών πληκτρολογήσουμε : τότε μπαίνουμε στην κατάσταση ex. Το vim υποστηρίζει τις εντολές του παλαιότερου κειμενογράφου ex. Οι πιο συχνά χρησιμοποιούμενες είναι οι: :! = Εκτέλεση ενός εξωτερικού προγράμματος. :e = Φόρτωση ενός αρχείου :g = Εκτέλεση εντολών για επιλεγμένα patterns :n = Όταν έχουμε να επεξεργαστούμε πολλά αρχεία μας φορτώνει το επόμενο :N = Ομοίως για το προηγούμενο :q = Έξοδος από το vim :q! = Αν δεν έχουμε σώσει τις αλλαγές μας, το vim γκαρίζει με το απλό q. Με το q! δηλώνουμε ότι ναι το ξέρω ότι δεν έχω σώσει. Άσε με να βγω :r = Μας εισάγει ένα αρχείο στο υπάρχον :s = Εύρεση και αντικατάσταση :v = Το ίδιο με g αλλά για τις υπόλοιπες γραμμές :w = Εγγραφή του αρχείου :x = Το ίδιο με :wq (Σώσιμο + Έξοδος) Η εντολή s Μία αρκετά χρήσιμη εντολή είναι η :s [εύρος]s/pattern για εύρεση/pattern για αντικατάσταση/[παράμετροι] Το εύρος δηλώνει σε ποιες γραμμές θέλουμε να ενεργήσει η s . Αν δεν δηλώσουμε τίποτα θα ενεργήσει μόνο στην τρέχουσα γραμμή. Ο χαρακτήρας . σημαίνει την τρέχουσα γραμμή και ο χαρακτήρας % όλο το αρχείο. Παραδείγματα: 5 , 9 s : Από την 5 η γραμμή μέχρι την 9 η ., + 5 s : Από την τρέχουσα μέχρι τις επόμενες 5 γραμμές %s : Όλο το αρχείο Οι πιο συχνά χρησιμοποιούμενες παράμετροι είναι οι εξής: c: Ζητά επιβεβαίωση για κάθε αλλαγή g: Αντικατάσταση όλων των pattern σε κάθε γραμμή και όχι μόνο του πρώτου i: Δεν κοιτάει κεφαλαία/πεζά O χαρακτήρας διαχωρισμού των πεδίων μπορεί να είναι οτιδήποτε και δεν είναι απαραίτητο να είναι / . Ας πούμε ότι θέλουμε να αλλάξουμε σε ένα αρχείο το /usr σε /usr/local . 1) :%s/\\/usr/\\/usr\\/local/g 2) :%s#/usr#/usr/local#g Το πρώτο παράδειγμα χρησιμοποιεί κανονικά το / για διαχωριστικό. Έτσι πρέπει οπουδήποτε έχουμε / μέσα στο pattern μας να το κάνουμε quote χρησιμοποιώντας την backslash, ενώ στο δεύτερο παράδειγμα επειδή χρησιμοποιούμε το # για διαχωριστικό δεν χρειάζεται να κάνουμε τίποτα. Η εντολή global Ας πoύμε τώρα και για το global. Το global ( :g ) μας επιτρέπει να εκτελέσουμε μια συγκεκριμένη εντολή σε όσες γραμμές πληρούν κάποια προϋπόθεση. πχ 1) :g/emacs/d 2) :g/usr/s/sbin/bin/g 3) :v/vim/d Η πρώτη εντολή θα ψάξει για γραμμές που έχουν την λέξη emacs και θα εκτελέσει την εντολή d . Δηλαδή θα διαγράψει όσες γραμμές έχουν την λέξη emacs. Η δεύτερη εντολή θα ψάξει για γραμμές που έχουν τη λέξη usr και θα εκτελέσει την εντολή s η οποία θα αλλάξει το sbin με το bin. Το συγκεκριμένο παράδειγμα είναι απλό και θα μπορούσε να γίνει και μόνο με την s. Η τρίτη εντολή θα βρει όσες γραμμές έχουν την λέξη vim και διαγράψει τις υπόλοιπες. Δηλαδή είναι το αντίστροφο της g . H εντολή που μπορούμε να εκτελέσουμε πρέπει να είναι εντολή του ex. Για παράδειγμα αν θέλουμε να σβήσουμε 10 χαρακτήρες με την εντολή 10x αυτό δεν γίνεται. Αν θέλουμε να εκτελέσουμε μια εντολή του vim μπορούμε να χρησιμοποιήσουμε το πρόθεμα normal όπως φαίνεται παρακάτω: :g/vim/normal 10x Η παραπάνω εντολή λέει στο vim να σβήσει τους πρώτους 10 χαρακτήρες από κάθε γραμμή που περιέχει την λέξη vim. Εκτελώντας εντολές μέσα από τον vim Η εντολή :! μας επιτρέπει να δούμε την έξοδο κάποιας εντολής. Δηλαδή αν γράψουμε :!ls θα μας εμφανίσει τα αρχεία που υπάρχουν στον τρέχοντα κατάλογο. Εκτός από αυτό πολλές φορές θέλουμε και να επεξεργαστούμε την έξοδο της εντολής ή απλά να την εισάγουμε στο αρχείο μας. Αυτό μπορεί να γίνει αν συνδυάσουμε τις εντολές :r και :! π.χ :r !ls και έχουμε το αποτέλεσμα της ls κατευθείαν μέσα στο buffer μας. Μπορούμε επίσης να κάνουμε και το αντίθετο. Αντί να εισάγουμε την έξοδο μιας εντολής στο buffer μας, να στείλουμε το buffer ως είσοδο μιας εντολής. Αυτό γίνεται με το πρόθεμα % Hello World :%!rev dlroW olleH Στο παραπάνω παράδειγμα, έχουμε \"Hello World\" και λέμε πάρτο και δωσ' το ως είσοδο στην εντολή rev η οποία αναποδογυρίζει την είσοδο της οπότε το buffer μας γίνεται dlroW olleH . Ενεργοποίηση διάφορων επιλογών Υπάρχουν πολλές επιλογές που μπορούν να δηλωθούν στο .vimrc ή κατά την διάρκεια του vim. background (bg) Όταν χρησιμοποιούμε το vim και όχι το gvim, μερικές φορές δεν λειτουργεί σωστά η αυτόματη ανίχνευση του φόντου του τερματικού με συνέπεια να μην φαίνονται καλά τα χρώματα. Για αυτό το λόγο μπορούμε να δηλώσουμε set background=dark ή set background=light hlsearch (hls) Όταν ψάξουμε κάτι, το vim το τονίζει ώστε να φαίνεται εύκολα. Αν τελειώσουμε αυτό που θέλαμε να κάνουμε και δεν θέλουμε να βλέπουμε τονισμένο κείμενο στα υπόλοιπα αποτελέσματα απενεργοποιούμε αυτή την επιλογή με :set nohls Αν ψάξουμε κάτι νέο, τότε θα ενεργοποιηθεί αυτόματα πάλι. list Εμφανίζει $ στο τέλος κάθε γραμμής και &#94;I για κάθε tab, έτσι μπορεί να μας διευκολύνει να διακρίνουμε τα tab όταν έχουμε κώδικα. listchars (lcs) Η κανονική λειτουργία του list δεν είναι και πολύ χρήσιμη. Με την listchars μπορούμε να αλλάξουμε την λειτουργία της. Οι επιλογές που δέχεται είναι οι εξής: eol : x Θα εμφανίζει τον χαρακτήρα x στο τέλος κάθε γραμμής tab : xy Για κάθε tab θα εμφανίζει στην αρχή τον χαρακτήρα x και έπειτα τον χαρακτήρα y μέχρι να τελειώσει το tab trail : x Θα εμφανίζει τον χαρακτήρα x για όσες spaces υπάρχουν στο τέλος της γραμμής extends : x Όταν η γραμμή είναι μεγαλύτερη από ό , τι χωράει στην οθόνη θα εμφανίζει τον χαρακτήρα x για να μας δείξει ότι η γραμμή φεύγει εκτός οθόνης Ένα παράδειγμα είναι το παρακάτω set listchars=eol:$,tab:>-,trail:. highlight SpecialKey ctermfg=red 1) printf(\"foo\\n\"); 2)>------printf(\"foo\\n\");...$ Το αποτέλεσμα φαίνεται στην μορφή 2) όπου βλέπουμε ότι χρησιμοποιούνται 8άρια tabs και ότι στο τέλος ξέφυγαν 3 spaces που πρέπει να σβήσουμε από τον κώδικα. textwidth (tw) Αν δηλωθεί ορίζει το μέγεθος κάθε γραμμής. Αν επιχειρήσουμε να περάσουμε το όριο αυτό θα γίνει αυτόματα wrap στην επόμενη γραμμή. Κανονικά είναι απενεργοποιημένη γιατί έχει νόημα σε κώδικα και όχι οπουδήποτε. Για να την ενεργοποιήσουμε σε συγκεκριμένο τύπο αρχείων μπορούμε να χρησιμοποιήσουμε τις autocommands του vim. π.χ autocmd FileType c setlocal textwidth=78 Η παραπάνω εντολή λέει ότι αν το αρχείο που έχουμε φορτώσει είναι αρχείο C, τότε θέσε μέγιστο όριο γραμμής τους 78 χαρακτήρες. Η setlocal θέτει την παράμετρο μόνο για το τοπικό buffer. Αν είχαμε ανοίξει πολλά αρχεία και χρησιμοποιούσαμε την set τότε θα έθεται την tw και για εκείνα το οποίο δεν θέλουμε. c_space_errors Αυτή δεν είναι παράμετρος του vim αλλά του syntax highlighter της C. Αν δηλωθεί, τότε θα εμφανίζει τα spaces που βρίσκονται στο τέλος με κόκκινο. Πρέπει να δηλωθεί πριν φορτωθεί ο syntax highlighter π.χ let c_space_errors = 1 syntax on ] και λειτουργεί ανεξάρτητα της list και μόνο σε C αρχεία. Η list είναι πιο εύχρηστη. Registers The quick brown fox jumps over the lazy dog Τρεία πουλάκια κάθονταν. Ας υποθέσουμε ότι έχουμε το παραπάνω κείμενο. Θέλουμε να αντιγράψουμε 50 γραμμές πιο κάτω το κείμενο με την αλεπού, οπότε πηγαίνουμε τον δρομέα πάνω του και πληκτρολογούμε yy για να αντιγραφεί η γραμμή. Τώρα μένει να πάμε το δρομέα εκεί που θέλουμε και να πατήσουμε p για να γίνει η επικόλληση. Βλέπουμε όμως ότι το τρία το έχουμε γράψει λάθος οπότε πληκτρολογούμε x και σβήνουμε το έψιλον. Αφού έχουμε μετακινηθεί 50 πιο κάτω πληκτρολογούμε p και βλέπουμε έκπληκτοι και νευριασμένοι ότι γίνεται επικόλληση το έψιλον που σβήσαμε. Κάθε εντολή που πραγματοποιεί αλλαγές τις εισάγει σε κάποιο register (κάτι σαν buffer). Οπότε με την εκτέλεση της x το αποτέλεσμα της yy έπαψε να υπάρχει. Εκτός από τον default register το vi μας επιτρέπει να χρησιμοποιήσουμε 26 ακόμη registers με ονόματα a-z. Για να προσπελάσουμε τον κάθε register χρησιμοποιούμε το \" . Οπότε στην παραπάνω περίπτωση μπορούμε αντί για yy να δώσουμε \"ayy οπότε το αποτέλεσμα θα μπει στον a register και δεν θα χαθεί όταν σβήσουμε το έψιλον. Έπειτα για να γίνει η επικόλληση δίνουμε \"ap . Marks Στο προηγούμενο μήνυμα είπαμε ότι αν εκτελέσουμε πχ 5dd θα σβήσουμε 5 γραμμές. Μπορεί όμως να μην ξέρουμε πόσες ακριβώς είναι οι γραμμές και εννοείται πως δεν θα κάτσουμε να μετράμε. Εδώ έρχονται τα marks τα οποία μας επιτρέπουν να μαρκάρουμε μια περιοχή και να εκτελούμε εντολές πάνω της. Τα marks είναι πάλι 26 με ονόματα a-z αλλά αυτή τη φορά χρησιμοποιούμε το ' (μονό εισαγωγικό). Ας υποθέσουμε ότι αυτό που μόλις έγραψα ήταν κείμενο στο vi. Ο δρομέας είναι στο Στο και πληκτρολογούμε ma. Αυτό λέει ότι μαρκάρισε την γραμμή ως a. Έπειτα πηγαίνουμε το δρομέα στη γραμμή Τα marks . Αν πληκτρολογήσουμε y'a θα αντιγράψει τις 6 αυτές γραμμές, ενώ με d'a μπορούμε να τις σβήσουμε. Τα marks είναι χρήσιμα αλλά η Visual κατάσταση δίνει μεγαλύτερη εποπτεία οπότε δεν πολύ χρησιμοποιούνται. Backreferences και Patterns Αυτό δεν είναι καθαρά vim αλλά και το sed και πολλά εργαλεία έχουν την ίδια σύνταξη. Είναι τεράστιο κεφάλαιο αλλά επειδή αναφέραμε την εντολή s πρέπει να αναφέρουμε και τα backreferences. Οι πιο βασικοί μεταχαρακτήρες που ισχύουν σε patterns είναι οι ακόλουθοι. . = Οποιοσδήποτε χαρακτήρας * = Ο προηγούμενος χαρακτήρας μπορεί να υπάρχει όσες φορές θέλει &#94; = αρχή της γραμμής $ = τέλος της γραμμής Παραδείγματα: H.llo = Hallo, Hbllo, Hello κτλ &#94;Hello = Η γραμμή αρχίζει με Hello. World$ = Η γραμμή τελειώνει με World H.*o = Οποιαδήποτε λέξη αρχίζει με H και περιέχει o (Το . λέει οποιοσδήποτε χαρακτήρας και το * όσες φορές θέλει ο προηγούμενος οπότε πιάνει τα πάντα) Τα backreferences χρησιμοποιούνται όταν θέλουμε να κρατήσουμε ένα μέρος του pattern. Δηλώνονται με τα \\( και \\) Ο Κώστας είναι ψηλός και ο Γιώργος είναι ψηλός Θέλουμε να αλλάξουμε την παραπάνω πρόταση ώστε να λέει ο Γιώργος είναι πολύ ψηλός. Η κλασική εντολή θα ήταν s/ψηλός/πολύ ψηλός/ Σε αυτή την περίπτωση όμως θα αλλάξει τον Κώστα ή με g και τον Κώστα. Άρα τι εντολή να βάλουμε; Εδώ θα χρησιμοποιήσουμε τα backreferences δηλαδή τις αναφορές. s/\\(Γιώργος.*\\) ψηλός/\\1 πολύ ψηλός/ Το Γιώργος.* ψηλός σημαίνει ψάξε για μια φράση που αρχίζει με την λέξη Γιώργος, μετά ακολουθεί οτιδήποτε και τελειώνει στη λέξη ψηλός. Οι quoted παρενθέσεις λένε ότι το κομμάτι αυτό το χρειάζομαι οπότε έχε το υπ' όψιν σου και θα στο ζητήσω κάποια στιγμή. Αυτό όλο θα το αντικαταστήσεις με την φράση \\1 πολύ ψηλός , όπου \\1 σημαίνει η πρώτη αναφορά που σου ζήτησα. Δηλαδή η φράση Γιώργος είναι ψηλός αντικαθίσταται με την φράση Γιώργος είναι πολύ ψηλός Απόκρυψη (δίπλωση) πληροφοριών με την foldmethod Το vim μάς επιτρέπει να αποκρύπτουμε (διπλώνουμε) πληροφορίες για ευκολότερη ανάγνωση. Αυτό χρησιμεύει σε μεγάλα κείμενα με πολλαπλές ενότητες. Η παράμετρος που δηλώνει την μέθοδο που θα χρησιμοποιηθεί για το δίπλωμα είναι η foldmethod . Κανονικά όταν τρέχουμε το vim είναι επιλεγμένη η manual για αυτό και δεν γίνεται κανένα δίπλωμα. Ακόμη, υπάρχουν οι indent , syntax , expr , marker . Η expr δέχεται ως όρισμα μια εντολή της αρεσκείας μας με βάση την οποία ορίζει το δίπλωμα. Είναι πολύ δυνατή αλλά δεν χρησιμοποιείται πολύ συχνά. Η indent και η syntax έχουν παρόμοια λειτουργία στις περισσότερες περιπτώσεις. Ας δούμε για παράδειγμα τον παρακάτω κώδικα: #include <stdio.h> #include <stdlib.h> int fact ( int n ); int main ( void ) { int i ; int k ; for ( i = 1 ; i < 8 ; i ++ ) { k = fact ( i ); printf ( \"Factorial of %d = %d \\n \" , i , k ); } return 0 ; } int fact ( int n ) { int res = 0 ; if ( n >= 0 ) { if ( n <= 1 ) res = 1 ; else res = fact ( n - 1 ) * n ; } return res ; } Αν εκτελέσουμε :set foldmethod=indent αυτή θα διπλώσει τον κώδικα μας με βάση την κάθε βαθμίδα indentation και θα προκύψει το εξής: #include <stdio.h> #include <stdlib.h> int fact ( int n ); int main ( void ) { +-- 8 lines : int i ; ------------------- } int fact ( int n ) { +-- 8 lines : int res = 0 ; ---------- } Όπως ήταν αναμενόμενο μας έκλεισε όλες τις δηλώσεις με βάση το indentation. Η μέθοδος αυτή λειτουργεί για οποιοδήποτε κείμενο χρησιμοποιεί indentation. Αντίθετα η syntax χρειάζεται να έχει δηλωθεί η σύνταξη του κάθε τύπου αρχείου για να λειτουργήσει, το vim όμως έχει ενσωματωμένες συντάξεις για πάρα πολλούς τύπους αρχείων. Ας δούμε τώρα πόσο διαφορετική θα είναι αυτή η μέθοδος. #include <stdio.h> #include <stdlib.h> int fact ( int n ); int main ( void ) +-- 10 lines : { ----------------------- int fact ( int n ) +-- 10 lines : { ----------------------- Εδώ βλέπουμε ότι αναγνωρίζεται η σύνταξη της C. Έτσι γνωρίζει ότι έχουμε δηλώσει κάποιες συναρτήσεις και γι' αυτό μας κρύβει όλη την συνάρτηση, οπότε οπτικά είναι καλύτερο για μεγάλους κώδικες. Κακά τα ψέμματα, τα αποτελέσματα και με τις δύο μεθόδους ήταν άθλια. Δεν μπορείς να δεις τίποτα. Σε αυτό παίζει ρόλο η επιλογή foldlevel η οποία ορίζει από ποια βαθμίδα και έπειτα θα γίνεται το δίπλωμα. Κανονικά έχει την τιμή 0 οπότε διπλώνονται όλες οι δηλώσεις. Οι περισσότεροι χρήστες βρίσκουν για κώδικα την τιμή 1 ως βέλτιστη, η οποία διπλώνει δηλώσεις από την 2η βαθμίδα και έπειτα. Ας δούμε τι αποτέλεσμα θα έχει αυτό στις δύο προηγούμενες περιπτώσεις. indent #include <stdio.h> #include <stdlib.h> int fact ( int n ); int main ( void ) { int i ; int k ; for ( i = 1 ; i < 8 ; i ++ ) { +--- 2 lines : k = fact ( i ); --------- } return 0 ; } int fact ( int n ) { int res = 0 ; if ( n >= 0 ) { +--- 4 lines : if ( n <= 1 ) ----------- } return res ; } Τώρα το αποτέλεσμα είναι πολύ καλύτερο. Έχουμε μια ιδέα τι κάνει η κάθε συνάρτηση και αποκρύπτονται πχ οι λεπτομέρειες του for. syntax #include <stdio.h> #include <stdlib.h> int fact ( int n ); int main ( void ) { int i ; int k ; +--- 4 lines : for ( i = 1 ; i < 8 ; i ++ ) { ------ return 0 ; } int fact ( int n ) { int res = 0 ; +--- 6 lines : if ( n >= 0 ) { ------------------- return res ; } Όπως και πριν το αποτέλεσμα της syntax είναι καλύτερο οπτικά γιατί γνωρίζει τις ιδιαιτερότητες της C. Συνδυασμοί πλήκτρων Όλες οι εντολές αναδίπλωσης ξεκινούν με z . zo = Άνοιγμα του fold στη θέση του δρομέα zO = Άνοιγμα του fold καθώς και αυτών που βρίσκονται μέσα σε αυτό zc = Κλείσιμο του fold στη θέση του δρομέα zC = Κλείσιμο του fold καθώς και αυτών που βρίσκονται μέσα σε αυτό za = Εναλλαγή της κατάστασης του fold (Άνοιγμα/Κλείσιμο) zA = Εναλλαγή της κατάστασης και αυτών που βρίσκονται μέσα zj = Μετακίνηση του δρομέα στο επόμενο fold zk = Μετακίνηση του δρομέα στο προηγούμενο fold zi = Εναλλαγή της κατάστασης foldenable με συνέπεια το άνοιγμα ή κλείσιμο όλων των folds zM = Θέτει στην foldlevel την τιμή 0 κλείνοντας ουσιαστικά όλα τα folds zR = Θέτει στην foldlevel την μέγιστη τιμή ανοίγοντας ουσιαστικά όλα τα folds zm = Μειώνει την foldlevel κατά 1 κλείνοντας μια βαθμίδα από folds zr = Αυξάνει την foldlevel κατά 1 ανοίγοντας μια βαθμίδα από folds Ας δούμε τώρα και την τρίτη μέθοδο που είναι η marker . Εδώ επιλέγουμε πως θέλουμε να γίνει δίπλωμα μόνο όπου υπάρχουν οι markers {{{ και }}} . Αυτή η μέθοδος έχει το καλό ότι επιλέγουμε εμείς να κάνουμε folding μόνο εκεί που θέλουμε να γίνει. Δεν χρησιμοποιείται πάρα πολύ σε κώδικα αλλά συνήθως σε αρχεία που δεν έχουν κάποια σύνταξη ή indentation. # {{{ Γεια σου κόσμε echo Hello World # }}} /* {{{ Γεια σου κόσμε */ printf(\"Hello World\\n\"); /* }}} */ Τα παραπάνω είναι δύο παραδείγματα για shell και C. Το κείμενο που βάζουμε μετά τον {{{ marker θα εμφανίζεται ως περιγραφή όταν το fold είναι κλειστό. Υπάρχουν αρκετοί στους οποίους οι μέθοδοι indent και syntax δεν αρέσουν γιατί δυσκολεύουν αντί να ευκολύνουν στη συγγραφή κώδικα. Υπάρχουν όμως περιπτώσεις που βολεύει η χρήση των markers όπως π.χ. στα αρχεία εκκίνησης του zsh. Για παράδειγμα ένα αρχείο zshrc μπορεί να φαίνεται ως εξής: +-- 36 lines: Δήλωση του prompt --------------------- +-- 57 lines: Λειτουργίες πλήκτρων ------------------- +-- 64 lines: Δήλωση μεταβλητών -------------------- +-- 41 lines: Δήλωση συντομεύσεων (aliases) ---- κτλ Έτσι, όταν θέλoυμε να αλλάξουμε ή να προσθέσουμε κάτι δεν χρειάζεται να ψάχνουμε μέσα σε 700 γραμμές. Απλά πηγαίνουμε στην κατηγορία που θέλουμε και ανοίγουμε το fold. Καλά και χρυσά τα folds, αλλά δεν μπορούμε κάθε φορά που ανοίγουμε ένα αρχείο να γράφουμε :set foldmethod=τάδε . Για αυτό το λόγο, το vim υποστηρίζει τα λεγόμενα modelines που είναι γραμμές οι οποίες λένε στο vim ποιες παραμέτρους να ενεργοποιήσει για το συγκεκριμένο αρχείο. [κείμενο]<κενό>vim:παράμετροι [κείμενο]<κενό>vim:set παράμετροι: [κείμενο] Αυτές είναι οι δύο μορφές που μπορούμε να χρησιμοποιήσουμε για να δηλώσουμε την modeline. Το vim ψάχνει ένα αριθμό γραμμών στην αρχή και στο τέλος του αρχείου για πιθανά modelines, έτσι μπορούμε να την δηλώσουμε είτε στην αρχή είτε στο τέλος του αρχείου μας. Πιθανά παραδείγματα # vim:filetype=zsh:foldmethod=marker Όπως αναφέρθηκε πιο πάνω μπορεί να χρησιμοποιηθεί στα αρχεία του zsh. Ο τύπος του αρχείου θα αναγνωριζόταν αυτόματα αλλά καλό είναι να τον δηλώνουμε. Όπως βλέπουμε στην σύνταξη, η πρώτη μορφή δεν επιτρέπει κείμενο στο τέλος, οπότε σε συγκεκριμένες περιπτώσεις πρέπει να χρησιμοποιηθεί η δεύτερη μορφή. /* vim:filetype=c:foldmethod=syntax *ΛΑΘΟΣ* /* vim:set filetype=c:foldmethod=syntax */ * ΣΩΣΤΟ * Οι modelines χρησιμοποιούνται για να δηλώσουμε οτιδήποτε παραμέτρους θέλουμε να ισχύουν για το συγκεκριμένο αρχείο μας και όχι μόνο για το folding. Έτσι, για λόγους ασφαλείας, δεν διαβάζονται όταν ο χρήστης είναι ο root. Αν ανοίξουμε ένα αρχείο ως root, θα πρέπει να εκτελέσουμε :set foldmethod=τάδε ακόμη και αν υπάρχει modeline. Η εντολή colorcolumn Για προγραμματισμό, παρόμοια και εξίσου χρήσιμη είναι και η colorcolumn. Πολλά IDE έχουν μια (πράσινη συνήθως) κατακόρυφη γραμμή που δηλώνει τα όρια του κώδικα για παράδειγμα 80 στήλες. Η colorcolumn κάνει ακριβώς το ίδιο. Το μόνο κακό είναι ότι λόγω της φύσης του vim έχει πλάτος ένα χαρακτήρα οπότε είναι λίγο χοντροκομμένη και μπορεί να κουράζει κάποιους. Μπορεί εύκολα να χρησιμοποιηθεί μόνο σε αρχεία προγραμματισμού. autocmd FileType c setlocal textwidth=78 autocmd FileType c setlocal colorcolumn=+1 Πχ. σε αρχεία γλώσσας C να χρησιμοποιούνται το πολύ 78 στήλες (από τη μάνα του το vim δεν πειράζει τον κώδικα αλλά τα σχόλια αναδιπλώνονται αυτόματα αν περάσουν τις 78 στήλες) και να χρωματιστεί η στήλη textwidth+1 δηλαδή η 79. Τοποθεσία κέρσορα :hi CursorLine cterm=NONE ctermbg=lightgrey :hi CursorColumn cterm=NONE ctermbg=lightgrey :nnoremap <Leader>c :set cursorline! cursorcolumn!<CR> Με τον συγκεκριμένο κώδικα γίνονται 3 πράγματα: 1) το highlight είναι γκρι 2) ΔΕΝ είναι υπογραμμισμένο 3) ΔΕΝ είναι ενεργοποιημένο, αλλά μπορεί πολύ εύκολα να ενεργοποιηθεί/απενεργοποιηθεί πατώντας \\c . Ελληνικός ορθογράφος Αν η διανομή μας έχει πακέτο με το Ελληνικό αρχείο ορθογραφίας του vim, τότε απλά το εγκαθιστούμε, Αν όχι, τότε πρέπει να το δημιουργήσουμε με βάση μία λίστα λέξεων. Πολλές διανομές εγκαθιστούν λίστες λέξεων για Ελληνικά για aspell, myspell, αλλά ας υποθέσουμε ότι δεν έχουμε τέτοιο πακέτο οπότε ας το κατεβάσουμε. mkdir foo; cd foo wget http://extensions.services.openoffice.org/e-files/1411/2/el_gr_v110.oxt unzip el_gr_v100.oxt Τα αρχεία που μας ενδιαφέρουν είναι το el_GR.dic που είναι η λίστα με τις λέξεις και το el_GR.aff που έχει διάφορα χαρακτηριστικά των Ελληνικών. Έπειτα τρέχουμε το vim για να δημιουργήσουμε το αρχείο και τρέχουμε :mkspell el el_GR Η εντολή θα δημιουργήσει ένα αρχείο el.utf-8.spl ή el.iso8859-7.spl ανάλογα με το encoding που έχoυμε με βάση τα αρχεία .aff και .dic που έχουν πρόθεμα el_GR . Έπειτα απλά πρέπει να το βάλουμε στο σωστό μέρος. mkdir -p ~/.vim/spell mv el.utf-8.spl ~/.vim/spell Από εδώ και πέρα έχουμε Ελληνικό ορθογράφο ο οποίος ενεργοποιείται με :set spell spelllang=el Τέλος μπορούμε να έχουμε ταυτόχρονα 2 λεξικά ενεργοποιημένα (πχ ελληνικό - αγγλικό) :set spell spelllang=el,en Για το λόγο αυτό παράξαμε παραπάνω την «precompiled» μορφή ώστε το vim να αναγνωρίζει γρήγορα μια λέξη και να μπορούμε να έχουμε φορτωμένα πολλά λεξικά. Ουσιαστικά η mkspell κάνει το αρχείο binary για να γίνεται πιο γρήγορα το matching. Παράδειγμα .vimrc Τα διπλά αυτάκια \" δηλώνουν σχόλια. \"Με την autoread αν το αρχείο έχει αλλάξει από το άνοιγμα του αλλά δεν \"έχει γίνει κάποια αλλαγή από εμάς, τότε διαβάζει ξανά αυτόματα το αρχείο. \"Το lazyredraw δεν σχεδιάζει ξανά την οθόνη κατά την εκτέλεση των macros. set autoread set lazyredraw set nomodeline set nobackup \"δεν κάνει αυτόματα backups set viminfo=\"NONE\" \"απενεργοποιεί το .viminfo \"Απενεργοποίηση του mouse if has('mouse') set mouse=a endif \"Σκοτεινό φόντο και εμφάνιση των tabs και των τελικών spaces σε κώδικα. set background=dark set listchars=eol:$,tab:>-,trail:. highlight SpecialKey ctermfg=red let c_space_errors = 1 \"Διάφορες custom λέξεις και patterns που θέλω να είναι τονισμένες. syntax match TadeName \"Pattern\" highlight match TadeName ctermfg=tadexroma \"Όταν διαβάζω αρχεία που βρίσκονται μέσα στο /var/log δηλαδή logs να πηγαίνει \"αυτόματα στο τέλος του αρχείου. Μέσα στον /var/log όμως το Slackware έχει \"και άλλους καταλόγους όπως π.χ τον κατάλογο με τις πληροφορίες των πακέτων. \"Εκεί δεν θέλω να με πηγαίνει στο τέλος. Παλαιότερα είχα regexp αλλά από μια \"έκδοση και μετά δεν έπαιζε οπότε μετράω τις / που υπάρχουν στο όνομα. \"Αν χαλάσει το match, να το κάνω stridx(s:name,'/',9) autocmd BufReadPost /var/log/* \\ let s:name = expand(\"<afile>:p\") | \\ if match(s:name,'/',0,4) == -1 | \\ exe \"normal G\" | \\ endif | \\ unlet! s:name \"Μερικές φορές θέλω να κάνω επικόλληση κάτι χωρίς όμως να χαλάσει η δομή του. \"Το vim παρέχει την επιλογή paste για αυτό. Έτσι με το F10 αλλάζω την επιλογή. \"Επίσης το F2 ενεργοποιεί/απενεργοποιεί την list ώστε να βλέπω σε κώδικα αν \"έχω ξεχάσει κενά ή tabs και το F8 απενεργοποιεί την hlsearch όταν έχω βρει \"αυτό που θέλω και δεν θέλω να βλέπω πλέον τα highlights. \"Key Mappings set pastetoggle=<F10> nmap <silent> <F2> :set list!<cr> imap <silent> <F2> <esc>:set list!<cr>a nmap <silent> <F8> :set hls!<cr> \"Τα leader και localleader είναι κάποια εικονικά πλήκτρα για την εύκολη χρήση \"συνδυασμών. Κανονικά είναι ρυθμισμένα να χρησιμοποιούν το backslash αλλά \"μπορούμε να αλλάξουμε την τιμή τους. Οι καρτέλες δεν έχουν και πολύ νόημα \"σε X τερματικά μια και υποστηρίζουν και αυτά καρτέλες αλλά είναι χρήσιμες στην \"κονσόλα. \"Αλλαγή των πλήκτρων leader από το default \\ \"let mapleader = ',' \"let maplocalleader = ',' \"Αποθήκευση αρχείου nmap <leader>w :w<cr> \"Μεταφορά στο προηγούμενο/επόμενο buffer nmap <leader>n :bn<cr> nmap <leader>p :bp<cr> \"Άνοιγμα νέας καρτέλας nmap <leader>to :tabnew<cr> \"Κλείσιμο τρέχουσας καρτέλας nmap <leader>tc :tabclose<cr> \"Μεταφορά στην προηγούμενη/επόμενη καρτέλα nmap <leader>tn :tabnext<cr> nmap <leader>tp :tabprev<cr> \"Κατάργηση των βελακίων ώστε να γίνουν συνήθεια τα hjkl. \"Τα απενεργοποιούμε μόνο στην normal κατάσταση \"γιατί στην insert και στην command δεν υπάρχουν εναλλακτικές (εκτός από macros). if &encoding == \"utf-8\" nnoremap <Left> :echoerr \"Το h αγκάθια έχει?\"<cr> nnoremap <Down> :echoerr \"Το j αγκάθια έχει?\"<cr> nnoremap <Up> :echoerr \"Το k αγκάθια έχει?\"<cr> nnoremap <Right> :echoerr \"Το l αγκάθια έχει?\"<cr> nnoremap <PageUp> :echoerr \"Το Ctrl-B αγκάθια έχει?\"<cr> nnoremap <PageDown> :echoerr \"Το Ctrl-F αγκάθια έχει?\"<cr> endif \"Για συγγραφή latex \"assign keyboard commands while using the greek keyboard: map Α A map Β B map Ψ C map Δ D map Ε E map Φ F map Γ G map Η H map Ι I map Ξ J map Κ K map Λ L map Μ M map Ν N map Ο O map Π P map Q Q map Ρ R map Σ S map Τ T map Θ U map Ω V map W W map Χ X map Υ Y map Ζ Z map α a map β b map ψ c map δ d map ε e map φ f map γ g map η h map ι i map ξ j map κ k map λ l map μ m map ν n map ο o map π p map q q map ρ r map σ s map τ t map θ u map ω v map ς w map χ x map υ y map ζ z Credits Τα credits στους imitheos, arkara, tsigarid. Όποιος κατάφερε και διάβασε μέχρι εδώ είναι ήρωας...","tags":"opensource","loc":"http://axilleas.me/el/blog/2013/vimtips","title":"Ένας σύντομος οδηγός για τον vim"},{"text":"Update : I just got a confirmation mail that my proposal got accepted! Read here. So, I decided to write some info regarding my involvement for this year's Google Summer of Code . I have been using/testing GitLab since version 2.0 (almost a year now) and I am thrilled to see how much it has growed since. This year I got a little more involved into this and I made two commits upstream. Nothing fancy, but I hope to contribute more as time passes by. In the rest of this article I will try to explain what GitLab is, how Fedora is involved into all this and what are the benefits of this involvement. This is the first of many follow-up posts I intend to write, so keep tight! What is GitLab? Fedora's involvement so far What are the benefits Get more ruby packages in the repos A new service for fedorahosted.org Next steps and things to overcome What is GitLab? GitLab is an open source MIT licenced git repository management application. It is built on Ruby on Rails and is one of the most popular projects featured on Github. It is used by many companies as their internal git management repository. The reason it gained so much popularity is that it bares a strong resemblance to github's looks and feels . It is a project with great potential, under heavy development with a release cycle every month. That makes it possible to apply bug fixes quite regularly and test new features. And since a picture is worth a thousand words, here is a demo site where you can test all the latest features. Fedora's involvement so far The thought of GitLab being packaged and deployed for Fedora Hosted isn't new. It all started last March when Dan Allen proposed GitLab to be used as a service for Fedora Hosted. If you follow the conversation it summarizes to some key points: Projects pages should be ideally hosted as $projectname.fedorahosted.org . GitLab and its dependencies should be packaged for Fedora and EPEL 6. Puppetize the whole thing up. There are some configs, but they'll sure need some adjustment. We need to form a team of maintainers for longterm support even after GSoC is over. There was even a post in GitLab's list, also by Dan Allen, bringing the project to the attention of the GitLab community. The most interesting thing was that the lead developer of GitLab was more than willing to help. In the end, there was an application but unfortunately that was the last anyone heard about the project. So, here we are a year after with me applying for the project. To be exact there is another sudent interested in this as well, so that makes it two of us. I have already expressed my interest in RubySIG and in the infrastructure mailing list. I was glad to see that there was a positive response from Dan Allen, as well as some valuable advice from user Ken Dreyer who currently tries to deal with Gitorious . What are the benefits There are two major benefits for Fedora. Get more ruby packages in the repos Prior to addressing my interest in the mailing lists, I approached Vít Ondruch to get some feedback about this task. He was very helpful and pointed me to what should be done as a first step. That is identify which gems are missing in Fedora and package them, compile a list of gems GitLab is using, including all their dependencies (and possibly bundled dependencies). For the first task, I used a hackish bash script which first accumulates all rubygems in a file and then removes the duplicate packages and the ones that are documentation. #!/bin/bash file_raw = '/home/axil/tools/fedora-gitlab/rubygems_fedora_raw' file_new = '/home/axil/tools/fedora-gitlab/rubygems_fedora' yum search all rubygem | awk '{print $1}' > $file_raw sed -e 's/rubygem-//g' -e 's/.noarch//g' -e 's/.x86_64//g' \\ -e '/i686/d' -e '/==/d' -e '/:/d' -e '/-doc/d' < $file_raw > $file_new In order to find what gems GitLab depends on, I used the Gemfile.lock and wrote a simple python script 1 that computes how many and which gems Fedora and GitLab have in common. Below are some draft 2 numbers and a bar chart. Gitlab uses: 203 gems. Fedora has packaged: 385 gems. There are 97 common gems. There should be packaged: 106 gems. Fedora will have 27.53 % more ruby packages, that is 482 gems in total. Not bad, 106 more ruby packages! That is a plus now that Fedora is considered one of Ruby's supported platforms . Update: I just found out about the gemfile tool that isitfedoraruby.com 3 is using. This will come in handy. A new service for fedorahosted.org After the packaging is done, the next big thing is the deployment process on Fedora Hosted as a new service. Quoting Dan Allen's thought : One of the key reasons I've been pushing for GitLab is because I see the potential it has for drastically improving the discoverability of the Fedora code base and encourage participation. I've been involved with a lot of projects on GitHub and I'm amazed by how simple it is to submit changes (to both code and documentation). In fact, it's often easier to send a patch with a description of the change than to create an issue...flipping the normal bug submitting process on its head. GitHub also works because it enables collaboration over coordination. You don't have to ask for permission on GitHub. You just do it. Then you can easily track when they get pulled in or changes are requested. (the same is true of GitLab). With GitLab, we can bring that experience to the Fedora community. It's a large enough community (esp in terms of repositories), that I'm positive we'd see that collaboration kindle within the Fedora instance. So yeah, this is a big deal from this point of view :) Next steps and things to overcome There is certainly a lot more to do. For starters, as a Fedora newbie, I have to run through the Ruby guidelines and learn about the philosophy of rpm. Luckily, I am not a linux newbie (I've been using Archlinux for 5 years) and I am adopting rapidly. Then, I need to learn some Ruby. I have already printed why's (poignant) Guide to Ruby which is considered a must read, and believe me it is! (download the pdf from here ). Learn Ruby the hard way is also a good starting point. Ι think I'm on the right track. Now, as far as the packaging process is concerned, here is what more needs to be done: MariaDB support. Since MariaDB will be the default implementation of MySQL in Fedora 19, GitLab will need to support it. Write systemd service files. I had made an attempt two months ago when I was trying to set up GitLab on Archlinux, but it is far from perfect. Packages to be EPEL compatible. A great advantage if GitLab gets packaged for Fedora, is that it would make it as easy as pie to install on a server running Red Hat, Centos, or some other rpm based distro. Ruby 2.0 compatibility. I don't think that'll be much of a stopper since GitLab is in the process of supporting it, but I put it here just in case. That's all for now. If you read through here you should have a good understanding of this project's goal. More posts to come! // Load the Visualization API and the piechart package. google.load('visualization', '1.0', {'packages':['corechart']}); // Set a callback to run when the Google Visualization API is loaded. google.setOnLoadCallback(drawChart); // Callback that creates and populates a data table, // instantiates the pie chart, passes in the data and // draws it. function drawChart() { // Create the data table. var data = new google.visualization.DataTable(); data.addColumn('string', ''); data.addColumn('number', 'rubygems'); data.addRows([ ['GitLab', 203], ['Fedora', 385], ['Common', 97], ['To be packaged', 106], ['Total after packaging', 482] ]); // Set chart options var options = {'title':'Numbers calculated on 08-04-2013', 'width':600, 'height':500}; // Instantiate and draw our chart, passing in some options. var chart = new google.visualization.BarChart(document.getElementById('rubygems_chart')); chart.draw(data, options); } I should write it in ruby, I know :p ↩ I say draft, mainly because that is a raw calculation of GitLab's dependencies. One has to take into account the different/old versions that may exist between Fedora and GtiLab. There are also some packages GitLab pulls from git and not rubygems.org. ↩ isitfedoraruby.com is a cool web app that was the result of last year's GSoC . ↩","tags":"opensource","loc":"http://axilleas.me/en/blog/2013/bringing-gitlab-in-fedora","title":"Bringing GitLab to Fedora"}]}