<!DOCTYPE html>
<html>
   <head>
   <meta charset="utf-8">
       <title>Ένας σύντομος οδηγός για τον vim</title>
       <meta charset="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <meta http-equiv="Pragma" content="no-cache" />
       <meta http-equiv="Expires" content="-1" />
       <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
       <link rel="stylesheet" href="/theme/css/friendly.css" type="text/css" />
       <link rel="stylesheet" href="/theme/css/print.css" type="text/css" media="print" />
       <link rel="stylesheet" type="text/css" href="/theme/tipuesearch/tipuesearch.css" media="screen">
       <link rel="stylesheet" href="/theme/css/font-awesome.min.css" type="text/css" />
       <link href="http://axilleas.me/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Over the line RSS Feed" />
</head>
<body>
   <header>
       <h1><a href="/" title="Mark it zero">Over the line</a></h1>
       <nav>
         <a href="/about" title="about me">whoami</a> &bull;
         <a href="/archives.html" title="Archives">Archives</a> &bull;
         <a id="subscribe-link" href="/rss" title="RSS feed" rel="nofollow">subscribe</a>
         <form id="searchform" action="/search.html" onsubmit="return (this.elements['q'].value.length > 0)">
               <input id="searchbox" type="text" name="q" size="12" placeholder="Search">
         </form>
       </nav>
   </header>

   <div id="main">
<article>
    <header>
<h1><a href="/el/blog/2013/vimtips" rel="bookmark">
    Ένας σύντομος οδηγός για τον vim
</a></h1>
<span title="~4186 words" id='stats'>~17 min read</span>
&bull;
<time datetime="2013-04-08 00:00:00+03:00" pubdate>Posted on
    Mon 08 April 2013
</time>
<span class="category">in <a href="/category/opensource.html">
    opensource</a>
</span>
    <ul class="tags">
    Tags:
        <li><a href="/tag/vim.html">vim</a></li>
    </ul>
    </header>

    <div class="body">
        <p>Ένα πολύ ωραίο thread σχετικά με τον vim editor βρίσκεται <a href="http://www.adslgr.com/forum/showthread.php?t=418489">εδώ</a>, όπου το μέλος <a href="http://lordkhelben.wordpress.com">imitheos</a> έχει παραθέσει πολλά χρήσιμα tips. Στο παρόν post θα προσπαθήσω να τα συγκεντρώσω όλα μαζί. Όπως θα διαπιστώσετε είναι ΠΑΡΑ πολλά, οπότε grab a cup of coffee, open vim and start practicing!</p>
<div class="toc">
<ul>
<li><a href="#_1">Οι συχνότερες λειτουργίες πλήκτρων</a></li>
<li><a href="#_2">Εύρος εντολών</a></li>
<li><a href="#_3">Εντολές με βάση το παρελθόν</a></li>
<li><a href="#_4">Εντολές εύρεσης</a></li>
<li><a href="#ex">Οι πιο συχνά χρησιμοποιούμενες εντολές στην κατάσταση ex</a></li>
<li><a href="#s">Η εντολή s</a></li>
<li><a href="#global">Η εντολή global</a></li>
<li><a href="#vim">Εκτελώντας εντολές μέσα από τον vim</a></li>
<li><a href="#_5">Ενεργοποίηση διάφορων επιλογών</a><ul>
<li><a href="#background-bg">background (bg)</a></li>
<li><a href="#hlsearch-hls">hlsearch (hls)</a></li>
<li><a href="#list">list</a></li>
<li><a href="#listchars-lcs">listchars (lcs)</a></li>
<li><a href="#textwidth-tw">textwidth (tw)</a></li>
<li><a href="#c_space_errors">c_space_errors</a></li>
</ul>
</li>
<li><a href="#registers">Registers</a></li>
<li><a href="#marks">Marks</a></li>
<li><a href="#backreferences-patterns">Backreferences και Patterns</a></li>
<li><a href="#foldmethod">Απόκρυψη (δίπλωση) πληροφοριών με την foldmethod</a></li>
<li><a href="#colorcolumn">Η εντολή colorcolumn</a></li>
<li><a href="#_6">Τοποθεσία κέρσορα</a></li>
<li><a href="#_7">Ελληνικός ορθογράφος</a></li>
<li><a href="#vimrc">Παράδειγμα .vimrc</a></li>
<li><a href="#credits">Credits</a></li>
</ul>
</div>
<h1 id="_1">Οι συχνότερες λειτουργίες πλήκτρων</h1>
<p>Υπάρχουν εκατοντάδες λειτουργίες πλήκτρων και ανάλογα με την κατάσταση που είμαστε το ίδιο πλήκτρο εκτελεί διαφορετική λειτουργία. Τα παρακάτω είναι τα πιο απλά και πιο συχνά χρησιμοποιούμενα.</p>
<div class="codehilite"><pre>h : Μετακίνηση του δρομέα αριστερά.
j : Μετακίνηση του δρομέα κάτω.
k : Μετακίνηση του δρομέα πάνω.
l : Μετακίνηση του δρομέρα δεξιά.
i : Μας βάζει στην κατάσταση εισαγωγής με τον δρομέα πριν την υπάρχουσα θέση
I : Το ίδιο με i αλλά στην αρχή της γραμμής
a : Μας βάζει στην κατάσταση εισαγωγής με τον δρομέα μετά την υπάρχουσα θέση
A : Το ίδιο με a αλλά στο τέλος της γραμμής
ο : Μας βάζει στην κατάσταση εισαγωγής αφού αλλάξει γραμμή
O : Το ίδιο με o αλλά εισάγει πριν την προηγούμενη γραμμή
p : Επικόλληση των περιεχομένων του buffer μετά από τον δρομέα.
r : Αντικαθιστά ένα χαρακτήρα.
R : Αντικαθιστά πολλούς χαρακτήρες
u : undo
Ctrl+R : αναίρεση του undo (redo)
y : Αντιγραφή στο buffer
d : Διαγραφή
x : Διαγραφή χαρακτήρα μετά τον δρομέα
X : Το ίδιο με x αλλά πριν τον δρομέα
D : Διαγραφή από τον δρομέα μέχρι το τέλος της γραμμής
G : Μετακίνηση σε κάποια γραμμή ή στο τέλος του αρχείου
J : Ενώνει την γραμμή με την επόμενη
. : Εκτελεί την προηγούμενη εντολή
</pre></div>


<h1 id="_2">Εύρος εντολών</h1>
<p>Πολλές εντολές δέχονται εύρος. Για παράδειγμα, αν πληκτρολογήσουμε <code>6x</code> θα σβήσει 6 χαρακτήρες. Η εντολή <code>5G</code> θα μας πάει στην 5η γραμμή. Οι εντολές <code>y</code> και <code>d</code> δέχονται και ένα όρισμα που δηλώνει την λειτουργία της εντολής. Τα πιο συχνά χρησιμοποιούμενα είναι <code>w</code> (μια λέξη), <code>$</code> (μέχρι το τέλος της γραμμής) και <code>d</code> (μία γραμμή). Στην περίπτωση του <code>y</code>, αντί για το <code>d</code> έχουμε το <code>y</code> (μία γραμμή).
Έτσι, έχουμε:</p>
<div class="codehilite"><pre>d$ : Διαγραφή μέχρι το τέλος της γραμμής (ίδιο με D) 
5dw : Διαγραφή 5 λέξεων 
yy : Αντιγραφή 1 γραμμής 
3dd : Διαγραφή 3 γραμμών 
d3d : Διαγραφή 3 γραμμών
</pre></div>


<p>Τα δύο τελευταία παραδείγματα βλέπουμε ότι κάνουν το ίδιο πράγμα ενώ έχουν διαφορετική σύνταξη. Το <code>3dd</code> θα εκτελέσει τρεις φορές την εντολή <code>dd</code> σβήνοντας δηλαδή από μία γραμμή ενώ το <code>d3d</code> θα σβήσει 3 γραμμές.</p>
<h1 id="_3">Εντολές με βάση το παρελθόν</h1>
<p>Άλλες εντολές μετακίνησης που χρησιμοποιούνται συχνά και έχουν βάση στο παρελθόν είναι:</p>
<div class="codehilite"><pre>Ctrl + B : Μια σελίδα πίσω 
Ctrl + F : Μια σελίδα μπροστά 
^ : Μετακίνηση στην αρχή της γραμμής 
$ : Μετακίνηση στο τέλος της γραμμής 
w : Μετακίνηση μια λέξη μπροστά 
b : Μετακίνηση μια λέξη πίσω
</pre></div>


<p>Και αυτές παίρνουν ορίσματα εύρους π.χ <code>5$</code></p>
<h1 id="_4">Εντολές εύρεσης</h1>
<div class="codehilite"><pre>/ : Εύρεση προς τα κάτω του ορίσματος που θέλουμε 
? : Εύρεση προς τα πάνω 
n : Εύρεση του επόμενου αποτελέσματος του 
/ ή ? N : Εύρεση του επόμενου αποτελέσματος στην αντίθετη κατεύθυνση
</pre></div>


<p>Αυτές οι εντολές χρησιμοποιούνται στην κατάσταση εντολών (command mode).</p>
<h1 id="ex">Οι πιο συχνά χρησιμοποιούμενες εντολές στην κατάσταση ex</h1>
<p>Αν στην κατάσταση εντολών πληκτρολογήσουμε <code>:</code> τότε μπαίνουμε στην κατάσταση ex. Το vim υποστηρίζει τις εντολές του παλαιότερου κειμενογράφου ex. Οι πιο συχνά χρησιμοποιούμενες είναι οι:</p>
<div class="codehilite"><pre>:! = Εκτέλεση ενός εξωτερικού προγράμματος. 
:e = Φόρτωση ενός αρχείου 
:g = Εκτέλεση εντολών για επιλεγμένα patterns 
:n = Όταν έχουμε να επεξεργαστούμε πολλά αρχεία μας φορτώνει το επόμενο 
:N = Ομοίως για το προηγούμενο 
:q = Έξοδος από το vim 
:q! = Αν δεν έχουμε σώσει τις αλλαγές μας, το vim γκαρίζει με το απλό q. Με το q! δηλώνουμε ότι ναι το ξέρω ότι δεν έχω σώσει. Άσε με να βγω 
:r = Μας εισάγει ένα αρχείο στο υπάρχον 
:s = Εύρεση και αντικατάσταση 
:v = Το ίδιο με g αλλά για τις υπόλοιπες γραμμές 
:w = Εγγραφή του αρχείου 
:x = Το ίδιο με :wq (Σώσιμο + Έξοδος)
</pre></div>


<h1 id="s">Η εντολή s</h1>
<p>Μία αρκετά χρήσιμη εντολή είναι η <code>:s</code></p>
<div class="codehilite"><pre>[εύρος]s/pattern για εύρεση/pattern για αντικατάσταση/[παράμετροι]
</pre></div>


<p>Το εύρος δηλώνει σε ποιες γραμμές θέλουμε να ενεργήσει η <code>s</code>. Αν δεν δηλώσουμε τίποτα θα ενεργήσει μόνο στην τρέχουσα γραμμή. Ο χαρακτήρας <code>.</code> σημαίνει την τρέχουσα γραμμή και ο χαρακτήρας <code>%</code> όλο το αρχείο. Παραδείγματα:</p>
<div class="codehilite"><pre><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="nl">s</span> <span class="p">:</span> <span class="err">Από</span> <span class="err">την</span> <span class="mi">5</span><span class="err">η</span> <span class="err">γραμμή</span> <span class="err">μέχρι</span> <span class="err">την</span> <span class="mi">9</span><span class="err">η</span> 
<span class="p">.,</span><span class="o">+</span><span class="mi">5</span><span class="nl">s</span><span class="p">:</span> <span class="err">Από</span> <span class="err">την</span> <span class="err">τρέχουσα</span> <span class="err">μέχρι</span> <span class="err">τις</span> <span class="err">επόμενες</span> <span class="mi">5</span> <span class="err">γραμμές</span> 
<span class="nf">%s</span><span class="o">:</span> <span class="err">Όλο</span> <span class="err">το</span> <span class="err">αρχείο</span>
</pre></div>


<p>Οι πιο συχνά χρησιμοποιούμενες παράμετροι είναι οι εξής:</p>
<div class="codehilite"><pre>c: Ζητά επιβεβαίωση για κάθε αλλαγή 
g: Αντικατάσταση όλων των pattern σε κάθε γραμμή και όχι μόνο του πρώτου 
i: Δεν κοιτάει κεφαλαία/πεζά
</pre></div>


<p>O χαρακτήρας διαχωρισμού των πεδίων μπορεί να είναι οτιδήποτε και δεν είναι απαραίτητο να είναι <code>/</code>. Ας πούμε ότι θέλουμε να αλλάξουμε σε ένα αρχείο το <code>/usr</code> σε <code>/usr/local</code>.</p>
<div class="codehilite"><pre>1) :%s/\/usr/\/usr\/local/g 
2) :%s#/usr#/usr/local#g
</pre></div>


<p>Το πρώτο παράδειγμα χρησιμοποιεί κανονικά το <code>/</code> για διαχωριστικό. Έτσι πρέπει οπουδήποτε έχουμε <code>/</code> μέσα στο pattern μας να το κάνουμε quote χρησιμοποιώντας την backslash, ενώ στο δεύτερο παράδειγμα επειδή χρησιμοποιούμε το <code>#</code> για διαχωριστικό δεν χρειάζεται να κάνουμε τίποτα.</p>
<h1 id="global">Η εντολή global</h1>
<p>Ας πoύμε τώρα και για το global. Το global (<code>:g</code>) μας επιτρέπει να εκτελέσουμε μια συγκεκριμένη εντολή σε όσες γραμμές πληρούν κάποια προϋπόθεση. πχ</p>
<div class="codehilite"><pre>1) :g/emacs/d 
2) :g/usr/s/sbin/bin/g 
3) :v/vim/d
</pre></div>


<p>Η πρώτη εντολή θα ψάξει για γραμμές που έχουν την λέξη emacs και θα εκτελέσει την εντολή <code>d</code>. Δηλαδή θα διαγράψει όσες γραμμές έχουν την λέξη emacs. Η δεύτερη εντολή θα ψάξει για γραμμές που έχουν τη λέξη usr και θα εκτελέσει την εντολή <code>s</code> η οποία θα αλλάξει το sbin με το bin. Το συγκεκριμένο παράδειγμα είναι απλό και θα μπορούσε να γίνει και μόνο με την <code>s.</code> Η τρίτη εντολή θα βρει όσες γραμμές έχουν την λέξη vim και διαγράψει τις υπόλοιπες. Δηλαδή είναι το αντίστροφο της <code>g</code>.</p>
<p>H εντολή που μπορούμε να εκτελέσουμε πρέπει να είναι εντολή του ex. Για παράδειγμα αν θέλουμε να σβήσουμε 10 χαρακτήρες με την εντολή <code>10x</code> αυτό δεν γίνεται. Αν θέλουμε να εκτελέσουμε μια εντολή του vim μπορούμε να χρησιμοποιήσουμε το πρόθεμα <code>normal</code> όπως φαίνεται παρακάτω:</p>
<div class="codehilite"><pre>:g/vim/normal 10x
</pre></div>


<p>Η παραπάνω εντολή λέει στο vim να σβήσει τους πρώτους 10 χαρακτήρες από κάθε γραμμή που περιέχει την λέξη vim.</p>
<h1 id="vim">Εκτελώντας εντολές μέσα από τον vim</h1>
<p>Η εντολή <code>:!</code> μας επιτρέπει να δούμε την έξοδο κάποιας εντολής. Δηλαδή αν γράψουμε <code>:!ls</code> θα μας εμφανίσει τα αρχεία που υπάρχουν στον τρέχοντα κατάλογο. Εκτός από αυτό πολλές φορές θέλουμε και να επεξεργαστούμε την έξοδο της εντολής ή απλά να την εισάγουμε στο αρχείο μας. Αυτό μπορεί να γίνει αν συνδυάσουμε τις εντολές <code>:r</code> και <code>:!</code> π.χ</p>
<div class="codehilite"><pre>:r !ls
</pre></div>


<p>και έχουμε το αποτέλεσμα της <code>ls</code> κατευθείαν μέσα στο buffer μας.</p>
<p>Μπορούμε επίσης να κάνουμε και το αντίθετο. Αντί να εισάγουμε την έξοδο μιας εντολής στο buffer μας, να στείλουμε το buffer ως είσοδο μιας εντολής. Αυτό γίνεται με το πρόθεμα <code>%</code></p>
<div class="codehilite"><pre>Hello World 
:%!rev 
dlroW olleH
</pre></div>


<p>Στο παραπάνω παράδειγμα, έχουμε "Hello World" και λέμε πάρτο και δωσ' το ως είσοδο στην εντολή <code>rev</code> η οποία αναποδογυρίζει την είσοδο της οπότε το buffer μας γίνεται <code>dlroW olleH</code>.</p>
<h1 id="_5">Ενεργοποίηση διάφορων επιλογών</h1>
<p>Υπάρχουν πολλές επιλογές που μπορούν να δηλωθούν στο .vimrc ή κατά την διάρκεια του vim.</p>
<h2 id="background-bg">background (bg)</h2>
<p>Όταν χρησιμοποιούμε το vim και όχι το gvim, μερικές φορές δεν λειτουργεί σωστά η αυτόματη ανίχνευση του φόντου του τερματικού με συνέπεια να μην φαίνονται καλά τα χρώματα. Για αυτό το λόγο μπορούμε να δηλώσουμε</p>
<div class="codehilite"><pre>set background=dark 
ή 
set background=light
</pre></div>


<h2 id="hlsearch-hls">hlsearch (hls)</h2>
<p>Όταν ψάξουμε κάτι, το vim το τονίζει ώστε να φαίνεται εύκολα. Αν τελειώσουμε αυτό που θέλαμε να κάνουμε και δεν θέλουμε να βλέπουμε τονισμένο κείμενο στα υπόλοιπα αποτελέσματα απενεργοποιούμε αυτή την επιλογή με</p>
<div class="codehilite"><pre>:set nohls
</pre></div>


<p>Αν ψάξουμε κάτι νέο, τότε θα ενεργοποιηθεί αυτόματα πάλι.</p>
<h2 id="list">list</h2>
<p>Εμφανίζει <code>$</code> στο τέλος κάθε γραμμής και <code>^I</code> για κάθε tab, έτσι μπορεί να μας διευκολύνει να διακρίνουμε τα tab όταν έχουμε κώδικα.</p>
<h2 id="listchars-lcs">listchars (lcs)</h2>
<p>Η κανονική λειτουργία του list δεν είναι και πολύ χρήσιμη. Με την listchars μπορούμε να αλλάξουμε την λειτουργία της. Οι επιλογές που δέχεται είναι οι εξής:</p>
<div class="codehilite"><pre><span class="n">eol</span><span class="o">:</span><span class="n">x</span> <span class="err">Θα</span> <span class="err">εμφανίζει</span> <span class="err">τον</span> <span class="err">χαρακτήρα</span> <span class="n">x</span> <span class="err">στο</span> <span class="err">τέλος</span> <span class="err">κάθε</span> <span class="err">γραμμής</span> 
<span class="n">tab</span><span class="o">:</span><span class="n">xy</span> <span class="err">Για</span> <span class="err">κάθε</span> <span class="n">tab</span> <span class="err">θα</span> <span class="err">εμφανίζει</span> <span class="err">στην</span> <span class="err">αρχή</span> <span class="err">τον</span> <span class="err">χαρακτήρα</span> <span class="n">x</span> <span class="err">και</span> <span class="err">έπειτα</span> <span class="err">τον</span> <span class="err">χαρακτήρα</span> <span class="n">y</span> <span class="err">μέχρι</span> <span class="err">να</span> <span class="err">τελειώσει</span> <span class="err">το</span> <span class="n">tab</span> 
<span class="n">trail</span><span class="o">:</span><span class="n">x</span> <span class="err">Θα</span> <span class="err">εμφανίζει</span> <span class="err">τον</span> <span class="err">χαρακτήρα</span> <span class="n">x</span> <span class="err">για</span> <span class="err">όσες</span> <span class="n">spaces</span> <span class="err">υπάρχουν</span> <span class="err">στο</span> <span class="err">τέλος</span> <span class="err">της</span> <span class="err">γραμμής</span> 
<span class="kd">extends</span><span class="o">:</span><span class="n">x</span> <span class="err">Όταν</span> <span class="err">η</span> <span class="err">γραμμή</span> <span class="err">είναι</span> <span class="err">μεγαλύτερη</span> <span class="err">από</span> <span class="err">ό</span><span class="o">,</span><span class="err">τι</span> <span class="err">χωράει</span> <span class="err">στην</span> <span class="err">οθόνη</span> <span class="err">θα</span> <span class="err">εμφανίζει</span> <span class="err">τον</span> <span class="err">χαρακτήρα</span> <span class="n">x</span> <span class="err">για</span> <span class="err">να</span> <span class="err">μας</span> <span class="err">δείξει</span> <span class="err">ότι</span> <span class="err">η</span> <span class="err">γραμμή</span> <span class="err">φεύγει</span> <span class="err">εκτός</span> <span class="err">οθόνης</span>
</pre></div>


<p>Ένα παράδειγμα είναι το παρακάτω </p>
<div class="codehilite"><pre>set listchars=eol:$,tab:&gt;-,trail:. 
highlight SpecialKey ctermfg=red


1) printf(&quot;foo\n&quot;); 
2)&gt;------printf(&quot;foo\n&quot;);...$
</pre></div>


<p>Το αποτέλεσμα φαίνεται στην μορφή 2) όπου βλέπουμε ότι χρησιμοποιούνται 8άρια tabs και ότι στο τέλος ξέφυγαν 3 spaces που πρέπει να σβήσουμε από τον κώδικα.</p>
<h2 id="textwidth-tw">textwidth (tw)</h2>
<p>Αν δηλωθεί ορίζει το μέγεθος κάθε γραμμής. Αν επιχειρήσουμε να περάσουμε το όριο αυτό θα γίνει αυτόματα wrap στην επόμενη γραμμή. Κανονικά είναι απενεργοποιημένη γιατί έχει νόημα σε κώδικα και όχι οπουδήποτε. Για να την ενεργοποιήσουμε σε συγκεκριμένο τύπο αρχείων μπορούμε να χρησιμοποιήσουμε τις autocommands του vim. π.χ</p>
<div class="codehilite"><pre>autocmd FileType c setlocal textwidth=78
</pre></div>


<p>Η παραπάνω εντολή λέει ότι αν το αρχείο που έχουμε φορτώσει είναι αρχείο C, τότε θέσε μέγιστο όριο γραμμής τους 78 χαρακτήρες. Η <code>setlocal</code> θέτει την παράμετρο μόνο για το τοπικό buffer. Αν είχαμε ανοίξει πολλά αρχεία και χρησιμοποιούσαμε την <code>set</code> τότε θα έθεται την <code>tw</code> και για εκείνα το οποίο δεν θέλουμε.</p>
<h2 id="c_space_errors">c_space_errors</h2>
<p>Αυτή δεν είναι παράμετρος του vim αλλά του syntax highlighter της C. Αν δηλωθεί, τότε θα εμφανίζει τα spaces που βρίσκονται στο τέλος με κόκκινο. Πρέπει να δηλωθεί πριν φορτωθεί ο syntax highlighter π.χ</p>
<div class="codehilite"><pre>let c_space_errors = 1 syntax on
</pre></div>


<p>]
και λειτουργεί ανεξάρτητα της list και μόνο σε C αρχεία. Η list είναι πιο εύχρηστη.</p>
<h1 id="registers">Registers</h1>
<div class="codehilite"><pre>The quick brown fox jumps over the lazy dog
Τρεία πουλάκια κάθονταν.
</pre></div>


<p>Ας υποθέσουμε ότι έχουμε το παραπάνω κείμενο. Θέλουμε να αντιγράψουμε 50 γραμμές πιο κάτω το κείμενο με την αλεπού, οπότε πηγαίνουμε τον δρομέα πάνω του και πληκτρολογούμε <code>yy</code> για να αντιγραφεί η γραμμή. Τώρα μένει να πάμε το δρομέα εκεί που θέλουμε και να πατήσουμε <code>p</code> για να γίνει η επικόλληση. Βλέπουμε όμως ότι το τρία το έχουμε γράψει λάθος οπότε πληκτρολογούμε x και σβήνουμε το έψιλον. Αφού έχουμε μετακινηθεί 50 πιο κάτω πληκτρολογούμε p και βλέπουμε έκπληκτοι και νευριασμένοι ότι γίνεται επικόλληση το έψιλον που σβήσαμε.</p>
<p>Κάθε εντολή που πραγματοποιεί αλλαγές τις εισάγει σε κάποιο register (κάτι σαν buffer). Οπότε με την εκτέλεση της x το αποτέλεσμα της yy έπαψε να υπάρχει.</p>
<p>Εκτός από τον default register το vi μας επιτρέπει να χρησιμοποιήσουμε 26 ακόμη registers με ονόματα a-z. Για να προσπελάσουμε τον κάθε register χρησιμοποιούμε το <code>"</code>.</p>
<p>Οπότε στην παραπάνω περίπτωση μπορούμε αντί για <code>yy</code> να δώσουμε <code>"ayy</code> οπότε το αποτέλεσμα θα μπει στον <code>a</code> register και δεν θα χαθεί όταν σβήσουμε το έψιλον. Έπειτα για να γίνει η επικόλληση δίνουμε <code>"ap</code>.</p>
<h1 id="marks">Marks</h1>
<p>Στο προηγούμενο μήνυμα είπαμε ότι αν εκτελέσουμε πχ <code>5dd</code> θα σβήσουμε 5 γραμμές. Μπορεί όμως να μην ξέρουμε πόσες ακριβώς είναι οι γραμμές και εννοείται πως δεν θα κάτσουμε να μετράμε. Εδώ έρχονται τα marks τα οποία μας επιτρέπουν να μαρκάρουμε μια περιοχή και να εκτελούμε εντολές πάνω της. Τα marks είναι πάλι 26 με ονόματα a-z αλλά αυτή τη φορά χρησιμοποιούμε το <code>'</code> (μονό εισαγωγικό).</p>
<p>Ας υποθέσουμε ότι αυτό που μόλις έγραψα ήταν κείμενο στο vi. Ο δρομέας είναι στο <em>Στο</em> και πληκτρολογούμε ma. Αυτό λέει ότι μαρκάρισε την γραμμή ως a. Έπειτα πηγαίνουμε το δρομέα στη γραμμή <em>Τα marks</em>. Αν πληκτρολογήσουμε <code>y'a</code> θα αντιγράψει τις 6 αυτές γραμμές, ενώ με <code>d'a</code> μπορούμε να τις σβήσουμε.</p>
<p>Τα marks είναι χρήσιμα αλλά η Visual κατάσταση δίνει μεγαλύτερη εποπτεία οπότε δεν πολύ χρησιμοποιούνται.</p>
<h1 id="backreferences-patterns">Backreferences και Patterns</h1>
<p>Αυτό δεν είναι καθαρά vim αλλά και το sed και πολλά εργαλεία έχουν την ίδια σύνταξη. Είναι τεράστιο κεφάλαιο αλλά επειδή αναφέραμε την εντολή <code>s</code> πρέπει να αναφέρουμε και τα backreferences.</p>
<p>Οι πιο βασικοί μεταχαρακτήρες που ισχύουν σε patterns είναι οι ακόλουθοι.</p>
<div class="codehilite"><pre>. = Οποιοσδήποτε χαρακτήρας
* = Ο προηγούμενος χαρακτήρας μπορεί να υπάρχει όσες φορές θέλει
^ = αρχή της γραμμής
$ = τέλος της γραμμής
</pre></div>


<p>Παραδείγματα:</p>
<div class="codehilite"><pre>H.llo = Hallo, Hbllo, Hello κτλ
^Hello = Η γραμμή αρχίζει με Hello.
World$ = Η γραμμή τελειώνει με World
H.*o = Οποιαδήποτε λέξη αρχίζει με H και περιέχει o
      (Το . λέει οποιοσδήποτε χαρακτήρας και το * όσες φορές
      θέλει ο προηγούμενος οπότε πιάνει τα πάντα)
</pre></div>


<p>Τα <em>backreferences</em> χρησιμοποιούνται όταν θέλουμε να κρατήσουμε ένα μέρος του pattern. Δηλώνονται με τα <code>\(</code> και <code>\)</code></p>
<div class="codehilite"><pre>Ο Κώστας είναι ψηλός και ο Γιώργος είναι ψηλός
</pre></div>


<p>Θέλουμε να αλλάξουμε την παραπάνω πρόταση ώστε να λέει ο Γιώργος είναι πολύ ψηλός. Η κλασική εντολή θα ήταν</p>
<div class="codehilite"><pre>s/ψηλός/πολύ ψηλός/
</pre></div>


<p>Σε αυτή την περίπτωση όμως θα αλλάξει τον Κώστα ή με <a href="#global">g</a> και τον Κώστα. Άρα τι εντολή να βάλουμε; Εδώ θα χρησιμοποιήσουμε τα backreferences δηλαδή τις αναφορές.</p>
<div class="codehilite"><pre>s/\(Γιώργος.*\) ψηλός/\1 πολύ ψηλός/
</pre></div>


<p>Το <code>Γιώργος.* ψηλός</code> σημαίνει ψάξε για μια φράση που αρχίζει με την λέξη Γιώργος, μετά ακολουθεί οτιδήποτε και τελειώνει στη λέξη ψηλός. Οι quoted παρενθέσεις λένε ότι το κομμάτι αυτό το χρειάζομαι οπότε έχε το υπ' όψιν σου και θα στο ζητήσω κάποια στιγμή. Αυτό όλο θα το αντικαταστήσεις με την φράση <code>\1 πολύ ψηλός</code>, όπου <code>\1</code> σημαίνει η πρώτη αναφορά που σου ζήτησα. Δηλαδή η φράση <code>Γιώργος είναι ψηλός</code> αντικαθίσταται με την φράση <code>Γιώργος είναι πολύ ψηλός</code></p>
<h1 id="foldmethod">Απόκρυψη (δίπλωση) πληροφοριών με την foldmethod</h1>
<p>Το vim μάς επιτρέπει να αποκρύπτουμε (διπλώνουμε) πληροφορίες για ευκολότερη ανάγνωση. Αυτό χρησιμεύει σε μεγάλα κείμενα με πολλαπλές ενότητες.
Η παράμετρος που δηλώνει την μέθοδο που θα χρησιμοποιηθεί για το δίπλωμα είναι η <code>foldmethod</code>. Κανονικά όταν τρέχουμε το vim είναι επιλεγμένη η manual για αυτό και δεν γίνεται κανένα δίπλωμα. Ακόμη, υπάρχουν οι <code>indent</code>,<code>syntax</code>,<code>expr</code>,<code>marker</code>.</p>
<p>Η expr δέχεται ως όρισμα μια εντολή της αρεσκείας μας με βάση την οποία ορίζει το δίπλωμα. Είναι πολύ δυνατή αλλά δεν χρησιμοποιείται πολύ συχνά.</p>
<p>Η indent και η syntax έχουν παρόμοια λειτουργία στις περισσότερες περιπτώσεις. Ας δούμε για παράδειγμα τον παρακάτω κώδικα:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">k</span><span class="o">=</span><span class="n">fact</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Factorial of %d = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">else</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Αν εκτελέσουμε <code>:set foldmethod=indent</code> αυτή θα διπλώσει τον κώδικα μας με βάση την κάθε βαθμίδα indentation και θα προκύψει το εξής:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">+--</span>  <span class="mi">8</span> <span class="nl">lines</span><span class="p">:</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="o">-------------------</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>               
<span class="o">+--</span>  <span class="mi">8</span> <span class="nl">lines</span><span class="p">:</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">----------</span>
</pre></div>


<p>}</p>
<p>Όπως ήταν αναμενόμενο μας έκλεισε όλες τις δηλώσεις με βάση το indentation. Η μέθοδος αυτή λειτουργεί για οποιοδήποτε κείμενο χρησιμοποιεί indentation. </p>
<p>Αντίθετα η syntax χρειάζεται να έχει δηλωθεί η σύνταξη του κάθε τύπου αρχείου για να λειτουργήσει, το vim όμως έχει ενσωματωμένες συντάξεις για πάρα πολλούς τύπους αρχείων. Ας δούμε τώρα πόσο διαφορετική θα είναι αυτή η μέθοδος.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="o">+--</span> <span class="mi">10</span> <span class="nl">lines</span><span class="p">:</span> <span class="p">{</span><span class="o">-----------------------</span>

<span class="kt">int</span> <span class="n">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="o">+--</span> <span class="mi">10</span> <span class="nl">lines</span><span class="p">:</span> <span class="p">{</span><span class="o">-----------------------</span>
</pre></div>


<p>Εδώ βλέπουμε ότι αναγνωρίζεται η σύνταξη της C. Έτσι γνωρίζει ότι έχουμε δηλώσει κάποιες συναρτήσεις και γι' αυτό μας κρύβει όλη την συνάρτηση, οπότε οπτικά είναι καλύτερο για μεγάλους κώδικες.</p>
<p>Κακά τα ψέμματα, τα αποτελέσματα και με τις δύο μεθόδους ήταν άθλια. Δεν μπορείς να δεις τίποτα. Σε αυτό παίζει ρόλο η επιλογή <code>foldlevel</code> η οποία ορίζει από ποια βαθμίδα και έπειτα θα γίνεται το δίπλωμα. Κανονικά έχει την τιμή 0 οπότε διπλώνονται όλες οι δηλώσεις. Οι περισσότεροι χρήστες βρίσκουν για κώδικα την τιμή 1 ως βέλτιστη, η οποία διπλώνει δηλώσεις από την 2η βαθμίδα και έπειτα. Ας δούμε τι αποτέλεσμα θα έχει αυτό στις δύο προηγούμενες περιπτώσεις.</p>
<p><em>indent</em></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+---</span>  <span class="mi">2</span> <span class="nl">lines</span><span class="p">:</span> <span class="n">k</span><span class="o">=</span><span class="n">fact</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="o">---------</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+---</span>  <span class="mi">4</span> <span class="nl">lines</span><span class="p">:</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">-----------</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Τώρα το αποτέλεσμα είναι πολύ καλύτερο. Έχουμε μια ιδέα τι κάνει η κάθε συνάρτηση και αποκρύπτονται πχ οι λεπτομέρειες του for.
<em>syntax</em></p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

<span class="o">+---</span>  <span class="mi">4</span> <span class="nl">lines</span><span class="p">:</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="o">------</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+---</span>  <span class="mi">6</span> <span class="nl">lines</span><span class="p">:</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">-------------------</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Όπως και πριν το αποτέλεσμα της syntax είναι καλύτερο οπτικά γιατί γνωρίζει τις ιδιαιτερότητες της C.</p>
<p><em>Συνδυασμοί πλήκτρων</em>
Όλες οι εντολές αναδίπλωσης ξεκινούν με <code>z</code>.</p>
<div class="codehilite"><pre>zo = Άνοιγμα του fold στη θέση του δρομέα
zO = Άνοιγμα του fold καθώς και αυτών που βρίσκονται μέσα σε αυτό
zc = Κλείσιμο του fold στη θέση του δρομέα
zC = Κλείσιμο του fold καθώς και αυτών που βρίσκονται μέσα σε αυτό
za = Εναλλαγή της κατάστασης του fold (Άνοιγμα/Κλείσιμο)
zA = Εναλλαγή της κατάστασης και αυτών που βρίσκονται μέσα
zj = Μετακίνηση του δρομέα στο επόμενο fold
zk = Μετακίνηση του δρομέα στο προηγούμενο fold
zi = Εναλλαγή της κατάστασης foldenable με συνέπεια το άνοιγμα ή κλείσιμο όλων των folds
zM = Θέτει στην foldlevel την τιμή 0 κλείνοντας ουσιαστικά όλα τα folds
zR = Θέτει στην foldlevel την μέγιστη τιμή ανοίγοντας ουσιαστικά όλα τα folds
zm = Μειώνει την foldlevel κατά 1 κλείνοντας μια βαθμίδα από folds
zr = Αυξάνει την foldlevel κατά 1 ανοίγοντας μια βαθμίδα από folds
</pre></div>


<p>Ας δούμε τώρα και την τρίτη μέθοδο που είναι η <code>marker</code>. Εδώ επιλέγουμε πως θέλουμε να γίνει δίπλωμα μόνο όπου υπάρχουν οι markers <code>{{{</code> και <code>}}}</code>. Αυτή η μέθοδος έχει το καλό ότι επιλέγουμε εμείς να κάνουμε folding μόνο εκεί που θέλουμε να γίνει. Δεν χρησιμοποιείται πάρα πολύ σε κώδικα αλλά συνήθως σε αρχεία που δεν έχουν κάποια σύνταξη ή indentation.</p>
<div class="codehilite"><pre># {{{ Γεια σου κόσμε
echo Hello World
# }}}

/* {{{ Γεια σου κόσμε */
printf(&quot;Hello World\n&quot;);
/* }}} */
</pre></div>


<p>Τα παραπάνω είναι δύο παραδείγματα για shell και C. Το κείμενο που βάζουμε μετά τον <code>{{{</code> marker θα εμφανίζεται ως περιγραφή όταν το fold είναι κλειστό.</p>
<p>Υπάρχουν αρκετοί στους οποίους οι μέθοδοι indent και syntax δεν αρέσουν γιατί δυσκολεύουν αντί να ευκολύνουν στη συγγραφή κώδικα. Υπάρχουν όμως περιπτώσεις που βολεύει η χρήση των markers όπως π.χ. στα αρχεία εκκίνησης του zsh. Για παράδειγμα ένα αρχείο zshrc μπορεί να φαίνεται ως εξής:</p>
<div class="codehilite"><pre>+-- 36 lines: Δήλωση του prompt ---------------------

+-- 57 lines: Λειτουργίες πλήκτρων -------------------

+-- 64 lines: Δήλωση μεταβλητών --------------------

+-- 41 lines: Δήλωση συντομεύσεων (aliases) ----
κτλ
</pre></div>


<p>Έτσι, όταν θέλoυμε να αλλάξουμε ή να προσθέσουμε κάτι δεν χρειάζεται να ψάχνουμε μέσα σε 700 γραμμές. Απλά πηγαίνουμε στην κατηγορία που θέλουμε και ανοίγουμε το fold.</p>
<p>Καλά και χρυσά τα folds, αλλά δεν μπορούμε κάθε φορά που ανοίγουμε ένα αρχείο να γράφουμε <code>:set foldmethod=τάδε</code>. Για αυτό το λόγο, το vim υποστηρίζει τα λεγόμενα <code>modelines</code> που είναι γραμμές οι οποίες λένε στο vim ποιες παραμέτρους να ενεργοποιήσει για το συγκεκριμένο αρχείο.</p>
<div class="codehilite"><pre>[κείμενο]&lt;κενό&gt;vim:παράμετροι 
[κείμενο]&lt;κενό&gt;vim:set παράμετροι: [κείμενο]
</pre></div>


<p>Αυτές είναι οι δύο μορφές που μπορούμε να χρησιμοποιήσουμε για να δηλώσουμε την modeline. Το vim ψάχνει ένα αριθμό γραμμών στην αρχή και στο τέλος του αρχείου για πιθανά modelines, έτσι μπορούμε να την δηλώσουμε είτε στην αρχή είτε στο τέλος του αρχείου μας.</p>
<p>Πιθανά παραδείγματα</p>
<div class="codehilite"><pre># vim:filetype=zsh:foldmethod=marker
</pre></div>


<p>Όπως αναφέρθηκε πιο πάνω μπορεί να χρησιμοποιηθεί στα αρχεία του zsh. Ο τύπος του αρχείου θα αναγνωριζόταν αυτόματα αλλά καλό είναι να τον δηλώνουμε. Όπως βλέπουμε στην σύνταξη, η πρώτη μορφή δεν επιτρέπει κείμενο στο τέλος, οπότε σε συγκεκριμένες περιπτώσεις πρέπει να χρησιμοποιηθεί η δεύτερη μορφή.</p>
<div class="codehilite"><pre><span class="cm">/* vim:filetype=c:foldmethod=syntax *ΛΑΘΟΣ* </span>
<span class="cm">/* vim:set filetype=c:foldmethod=syntax */</span> <span class="o">*</span><span class="err">ΣΩΣΤΟ</span><span class="o">*</span>
</pre></div>


<p>Οι modelines χρησιμοποιούνται για να δηλώσουμε οτιδήποτε παραμέτρους θέλουμε να ισχύουν για το συγκεκριμένο αρχείο μας και όχι μόνο για το folding. Έτσι, για λόγους ασφαλείας, δεν διαβάζονται όταν ο χρήστης είναι ο root. Αν ανοίξουμε ένα αρχείο ως root, θα πρέπει να εκτελέσουμε <code>:set foldmethod=τάδε</code> ακόμη και αν υπάρχει modeline.</p>
<h1 id="colorcolumn">Η εντολή colorcolumn</h1>
<p>Για προγραμματισμό, παρόμοια και εξίσου χρήσιμη είναι και η colorcolumn. Πολλά IDE έχουν μια (πράσινη συνήθως) κατακόρυφη γραμμή που δηλώνει τα όρια του κώδικα για παράδειγμα 80 στήλες. Η colorcolumn κάνει ακριβώς το ίδιο. Το μόνο κακό είναι ότι λόγω της φύσης του vim έχει πλάτος ένα χαρακτήρα οπότε είναι λίγο χοντροκομμένη και μπορεί να κουράζει κάποιους. Μπορεί εύκολα να χρησιμοποιηθεί μόνο σε αρχεία προγραμματισμού.</p>
<div class="codehilite"><pre>autocmd FileType c setlocal textwidth=78 
autocmd FileType c setlocal colorcolumn=+1
</pre></div>


<p>Πχ. σε αρχεία γλώσσας C να χρησιμοποιούνται το πολύ 78 στήλες (από τη μάνα του το vim δεν πειράζει τον κώδικα αλλά τα σχόλια αναδιπλώνονται αυτόματα αν περάσουν τις 78 στήλες) και να χρωματιστεί η στήλη textwidth+1 δηλαδή η 79.</p>
<h1 id="_6">Τοποθεσία κέρσορα</h1>
<div class="codehilite"><pre>:hi CursorLine   cterm=NONE ctermbg=lightgrey
:hi CursorColumn cterm=NONE ctermbg=lightgrey
:nnoremap &lt;Leader&gt;c :set cursorline! cursorcolumn!&lt;CR&gt;
</pre></div>


<p>Με τον συγκεκριμένο κώδικα γίνονται 3 πράγματα:
1) το highlight είναι γκρι
2) ΔΕΝ είναι υπογραμμισμένο
3) ΔΕΝ είναι ενεργοποιημένο, αλλά μπορεί πολύ εύκολα να ενεργοποιηθεί/απενεργοποιηθεί πατώντας <code>\c</code>.</p>
<h1 id="_7">Ελληνικός ορθογράφος</h1>
<p>Αν η διανομή μας έχει πακέτο με το Ελληνικό αρχείο ορθογραφίας του vim, τότε απλά το εγκαθιστούμε, Αν όχι, τότε πρέπει να το δημιουργήσουμε με βάση μία λίστα λέξεων. Πολλές διανομές εγκαθιστούν λίστες λέξεων για Ελληνικά για aspell, myspell,  αλλά ας υποθέσουμε ότι δεν έχουμε τέτοιο πακέτο οπότε ας το κατεβάσουμε.</p>
<div class="codehilite"><pre>mkdir foo; cd foo 
wget http://extensions.services.openoffice.org/e-files/1411/2/el_gr_v110.oxt 
unzip el_gr_v100.oxt
</pre></div>


<p>Τα αρχεία που μας ενδιαφέρουν είναι το <code>el_GR.dic</code> που είναι η λίστα με τις λέξεις και το <code>el_GR.aff</code> που έχει διάφορα χαρακτηριστικά των Ελληνικών. Έπειτα τρέχουμε το vim για να δημιουργήσουμε το αρχείο και τρέχουμε</p>
<div class="codehilite"><pre>:mkspell el el_GR
</pre></div>


<p>Η εντολή θα δημιουργήσει ένα αρχείο <code>el.utf-8.spl</code> ή <code>el.iso8859-7.spl</code> ανάλογα με το encoding που έχoυμε με βάση τα αρχεία <code>.aff</code> και <code>.dic</code> που έχουν πρόθεμα <code>el_GR</code>. Έπειτα απλά πρέπει να το βάλουμε στο σωστό μέρος.</p>
<div class="codehilite"><pre>mkdir -p ~/.vim/spell 
mv el.utf-8.spl ~/.vim/spell
</pre></div>


<p>Από εδώ και πέρα έχουμε Ελληνικό ορθογράφο ο οποίος ενεργοποιείται με</p>
<div class="codehilite"><pre>:set spell spelllang=el
</pre></div>


<p>Τέλος μπορούμε να έχουμε ταυτόχρονα 2 λεξικά ενεργοποιημένα (πχ ελληνικό - αγγλικό)</p>
<div class="codehilite"><pre>:set spell spelllang=el,en
</pre></div>


<p>Για το λόγο αυτό παράξαμε παραπάνω την «precompiled» μορφή ώστε το vim να αναγνωρίζει γρήγορα μια λέξη και να μπορούμε να έχουμε φορτωμένα πολλά λεξικά. Ουσιαστικά η mkspell κάνει το αρχείο binary για να γίνεται πιο γρήγορα το matching.</p>
<h1 id="vimrc">Παράδειγμα .vimrc</h1>
<p><em>Τα διπλά αυτάκια <code>"</code> δηλώνουν σχόλια.</em></p>
<div class="codehilite"><pre>&quot;Με την autoread αν το αρχείο έχει αλλάξει από το άνοιγμα του αλλά δεν
&quot;έχει γίνει κάποια αλλαγή από εμάς, τότε διαβάζει ξανά αυτόματα το αρχείο. 
&quot;Το lazyredraw δεν σχεδιάζει ξανά την οθόνη κατά την εκτέλεση των macros.

set autoread
set lazyredraw
set nomodeline
set nobackup        &quot;δεν κάνει αυτόματα backups
set viminfo=&quot;NONE&quot;  &quot;απενεργοποιεί το .viminfo

&quot;Απενεργοποίηση του mouse 
 if has(&#39;mouse&#39;)
     set mouse=a
 endif

&quot;Σκοτεινό φόντο και εμφάνιση των tabs και των τελικών spaces σε κώδικα.
set background=dark
set listchars=eol:$,tab:&gt;-,trail:.
highlight SpecialKey ctermfg=red
let c_space_errors = 1

&quot;Διάφορες custom λέξεις και patterns που θέλω να είναι τονισμένες.
syntax match TadeName &quot;Pattern&quot;
highlight match TadeName ctermfg=tadexroma

&quot;Όταν διαβάζω αρχεία που βρίσκονται μέσα στο /var/log δηλαδή logs να πηγαίνει
&quot;αυτόματα στο τέλος του αρχείου. Μέσα στον /var/log όμως το Slackware έχει
&quot;και άλλους καταλόγους όπως π.χ τον κατάλογο με τις πληροφορίες των πακέτων.
&quot;Εκεί δεν θέλω να με πηγαίνει στο τέλος. Παλαιότερα είχα regexp αλλά από μια
&quot;έκδοση και μετά δεν έπαιζε οπότε μετράω τις / που υπάρχουν στο όνομα.
&quot;Αν χαλάσει το match, να το κάνω stridx(s:name,&#39;/&#39;,9)
autocmd BufReadPost /var/log/*
\ let s:name = expand(&quot;&lt;afile&gt;:p&quot;) |
\ if match(s:name,&#39;/&#39;,0,4) == -1 |
\   exe &quot;normal G&quot; |
\ endif |
\ unlet! s:name

&quot;Μερικές φορές θέλω να κάνω επικόλληση κάτι χωρίς όμως να χαλάσει η δομή του.
&quot;Το vim παρέχει την επιλογή paste για αυτό. Έτσι με το F10 αλλάζω την επιλογή.
&quot;Επίσης το F2 ενεργοποιεί/απενεργοποιεί την list ώστε να βλέπω σε κώδικα αν
&quot;έχω ξεχάσει κενά ή tabs και το F8 απενεργοποιεί την hlsearch όταν έχω βρει
&quot;αυτό που θέλω και δεν θέλω να βλέπω πλέον τα highlights.
&quot;Key Mappings
set pastetoggle=&lt;F10&gt;
nmap &lt;silent&gt; &lt;F2&gt; :set list!&lt;cr&gt;
imap &lt;silent&gt; &lt;F2&gt; &lt;esc&gt;:set list!&lt;cr&gt;a
nmap &lt;silent&gt; &lt;F8&gt; :set hls!&lt;cr&gt;

&quot;Τα leader και localleader είναι κάποια εικονικά πλήκτρα για την εύκολη χρήση
&quot;συνδυασμών. Κανονικά είναι ρυθμισμένα να χρησιμοποιούν το backslash αλλά
&quot;μπορούμε να αλλάξουμε την τιμή τους. Οι καρτέλες δεν έχουν και πολύ νόημα
&quot;σε X τερματικά μια και υποστηρίζουν και αυτά καρτέλες αλλά είναι χρήσιμες στην
&quot;κονσόλα.

&quot;Αλλαγή των πλήκτρων leader από το default \
&quot;let mapleader = &#39;,&#39;
&quot;let maplocalleader = &#39;,&#39;

&quot;Αποθήκευση αρχείου
nmap &lt;leader&gt;w :w&lt;cr&gt;

&quot;Μεταφορά στο προηγούμενο/επόμενο buffer
nmap &lt;leader&gt;n :bn&lt;cr&gt;
nmap &lt;leader&gt;p :bp&lt;cr&gt;

&quot;Άνοιγμα νέας καρτέλας
nmap &lt;leader&gt;to :tabnew&lt;cr&gt;
&quot;Κλείσιμο τρέχουσας καρτέλας
nmap &lt;leader&gt;tc :tabclose&lt;cr&gt;
&quot;Μεταφορά στην προηγούμενη/επόμενη καρτέλα
nmap &lt;leader&gt;tn :tabnext&lt;cr&gt;
nmap &lt;leader&gt;tp :tabprev&lt;cr&gt;

&quot;Κατάργηση των βελακίων ώστε να γίνουν συνήθεια τα hjkl. 
&quot;Τα απενεργοποιούμε μόνο στην normal κατάσταση
&quot;γιατί στην insert και στην command δεν υπάρχουν εναλλακτικές (εκτός από macros).

if &amp;encoding == &quot;utf-8&quot;
  nnoremap &lt;Left&gt;     :echoerr &quot;Το h αγκάθια έχει?&quot;&lt;cr&gt;
  nnoremap &lt;Down&gt;     :echoerr &quot;Το j αγκάθια έχει?&quot;&lt;cr&gt;
  nnoremap &lt;Up&gt;       :echoerr &quot;Το k αγκάθια έχει?&quot;&lt;cr&gt;
  nnoremap &lt;Right&gt;    :echoerr &quot;Το l αγκάθια έχει?&quot;&lt;cr&gt;
  nnoremap &lt;PageUp&gt;   :echoerr &quot;Το Ctrl-B αγκάθια έχει?&quot;&lt;cr&gt;
  nnoremap &lt;PageDown&gt; :echoerr &quot;Το Ctrl-F αγκάθια έχει?&quot;&lt;cr&gt;
endif

&quot;Για συγγραφή latex
&quot;assign keyboard commands while using the greek keyboard:
map Α A
map Β B
map Ψ C
map Δ D
map Ε E
map Φ F
map Γ G
map Η H
map Ι I
map Ξ J
map Κ K
map Λ L
map Μ M
map Ν N
map Ο O
map Π P
map Q Q
map Ρ R
map Σ S
map Τ T
map Θ U
map Ω V
map W W
map Χ X
map Υ Y
map Ζ Z
map α a
map β b
map ψ c
map δ d
map ε e
map φ f
map γ g
map η h
map ι i
map ξ j
map κ k
map λ l
map μ m
map ν n
map ο o
map π p
map q q
map ρ r
map σ s
map τ t
map θ u
map ω v
map ς w
map χ x
map υ y
map ζ z
</pre></div>


<h1 id="credits">Credits</h1>
<p>Τα credits στους imitheos, arkara, tsigarid. 
Όποιος κατάφερε και διάβασε μέχρι εδώ είναι ήρωας... </p>
    </div>

    <div class="neighbors"></div>

      <nav class="older">
          <a href="http://axilleas.me/en/blog/2013/bringing-gitlab-in-fedora">
              <span class="lpin"></span>
              Bringing GitLab to Fedora
          </a>
      </nav>

      <nav class="newer">
          <a href="http://axilleas.me/en/blog/2013/nasa-spaceappschallenge-2013">
              Nominated for Space Apps Challenge 2013
              <span class="rpin"></span>
          </a>
      </nav>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'kissmyarch';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></article>
   </div>

   <footer>
       <p>Powered by <a href="http://docs.getpelican.com">
           Pelican</a> using <a href="https://github.com/axilleas/pelican-uberspot">uberspot theme</a> &bull;
         Background image from <a href="http://subtlepatterns.com/">Subtle patterns</a> &bull;
               <a href="https://github.com/axilleas/axilleas.github.io/tree/source" title="Source code">Source code</a>
</p>


 <p><a id="cc-logo" title="Creative Commons License"
 rel="license" href="http://creativecommons.org/licenses/by/4.0/"></a>
 Except where otherwise noted, content on this site is licensed under a<br />
 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>

   </footer>
     <!-- Piwik -->
    <script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://piwik2-glb.rhcloud.com/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "5"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <!-- End Piwik Code -->
</body>
</html>